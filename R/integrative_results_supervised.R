#' Downstream analysis for integrated multi-omics data - Sparse Supervised models
#'
#' @param multiassay Multiassay experiment object generated by Omix
#' @param integration_model Possible unsupervised integration methods are `DIABLO`, `sMBPLS`
#' @param dependent Dependent variable for groups.
#' @param correlation_threshold Absolute correlation threshold to draw edges
#' in the network
#' @param disease_id OpenTargets disease id. Default to "MONDO_0004975"
#' (Alzheimer's Disease) Different disease ontologies can be found on
#' https://www.ebi.ac.uk/ols/ontologies
#' @param sense_check_variable sense check
#' @param covariates cov
#' @param community_detection community detection method
#' @param TF_fp file path GMT file with Transcription Factors and target genes. Check `https://maayanlab.cloud/chea3/`
#' @param component Component to extract the multi-omics singature from
#'
#' @return List object of integrated results
#'
#' @family Multi-omic integration downstream analysis
#'
#' @importFrom purrr possibly
#' @importFrom clusterProfiler enrichGO compareCluster
#' @importFrom enrichplot pairwise_termsim
#' @importFrom org.Hs.eg.db org.Hs.eg.db
#' @importFrom MOFA2 get_weights correlate_factors_with_covariates plot_variance_explained
#' @export

integrative_results_sparse_supervised <- function(multiassay,
                                           integration_model = "sMBPLS",
                                           dependent = "PHF1",
                                           component = 1,
                                           sense_check_variable = "PHF1",
                                           covariates = c("PHF1", "amyloid", "AT8"),
                                           correlation_threshold = 0.4,
                                           community_detection = "leading_eigen",
                                           disease_id = "MONDO_0004975",
                                           TF_fp) {
  cli::cli_h2("Generating integrative muti-omics results ")

  integrated_object <- multiassay@metadata$integration[[integration_model]]
  variance <- data.frame(t(do.call(rbind, integrated_object$prop_expl_var)))
  variance$mRNA <- signif(variance$mRNA, 3)
  variance$proteins <- signif(variance$proteins, 3)
  metadata <- multiassay@metadata[["multimodal_object"]][["metadata"]]


  ## Sign
  cli::cli_text("Retrieving multi-omics signatures...")
  args <- list(
    integrated_object = integrated_object,
    metadata =  metadata,
    covariate = dependent,
    relevant_component = "comp1"
  )
  sign <- do.call(sign_signature, args)

  signatures <- extract_multiomic_signature(multiassay,
    integration = integration_model,
    component = component
  )


  ## Multi-omics network
  args <- list(
    integrated_object = integrated_object,
    metadata = metadata,
    component = component,
    sense_check_variable = NULL
  )

  # cli::cli_text("Retrieving weights...")
  loadings <- do.call(extract_loadings, args)

  cli::cli_text("Generating multi-omics network...")
  multiomic_networks <- list()
  multiomic_networks$positive <- multiomics_network(
    multiassay = multiassay,
    list = signatures$positive,
    correlation_threshold = correlation_threshold
  )

  multiomic_networks$negative <- multiomics_network(
    multiassay = multiassay,
    list = signatures$negative,
    correlation_threshold = correlation_threshold
  )


  ## Network communities detection
  cli::cli_text("Detecting network communities...")
  communities_pos_neg <- list()
  communities_pos_neg$positive <- communities_network(
    igraph = multiomic_networks$positive$graph,
    community_detection = community_detection
  )
  communities_pos_neg$negative <- communities_network(
    igraph = multiomic_networks$negative$graph,
    community_detection = community_detection
  )


  ## Cell type enrichment
  cli::cli_text("Cell type enrichment of communities...")

  cell_type <- list()
  cell_type$positive <- cell_type_enrichment(
    multiassay = multiassay,
    communities = lapply(communities_pos_neg$positive$communities, function(x) {
      sub("\\_.*", "", x)
    })
  )
  cell_type$negative <- cell_type_enrichment(
    multiassay = multiassay,
    communities = lapply(communities_pos_neg$negative$communities, function(x) {
      sub("\\_.*", "", x)
    })
  )


  ## Functional enrichment
  cli::cli_text("Functional enrichment of communities...")

  communities_positive <- lapply(communities_pos_neg$positive$communities, function(x) {
    sub("\\_.*", "", x)
  })
  communities_negative <- lapply(communities_pos_neg$negative$communities, function(x) {
    sub("\\_.*", "", x)
  })

  enrichment <- list()
  enrichment$positive <- lapply(communities_positive, pathway_analysis_enrichr)
  enrichment$negative <- lapply(communities_negative, pathway_analysis_enrichr)


  ## Transcription Factor enrichment
  cli::cli_text("Transcription factor - target gene enrichment in communities...")

  TF <- list()
  TF$positive <- Transcription_Factor_enrichment_supervised(
    multiassay=multiassay,
    communities = communities_pos_neg$positive$communities,
    TF_gmt = TF_fp,
    direction = "positive",
    signatures = signatures$positive
  )

  TF$negative <- Transcription_Factor_enrichment_supervised(
    multiassay=multiassay,
    communities = communities_pos_neg$negative$communities,
    TF_gmt = TF_fp,
    direction = "negative",
    signatures = signatures$negative
  )

  ## Multi-omics modules (eigenvalue)
  cli::cli_text("Computing module eigen expression for communities...")

  modules <- list()

  modules$positive <- multiomics_modules(
    multiassay = multiassay,
    metadata = metadata,
    covariates = covariates,
    communities = communities_pos_neg$positive$communities
  )

  modules$negative <- multiomics_modules(
    multiassay = multiassay,
    metadata = metadata,
    covariates = covariates,
    communities = communities_pos_neg$negative$communities
  )

  boxplots <- list()
  for (i in colnames(modules$positive$modules_eigen_value)) {
    boxplots$positive[[i]] <- ggpubr::ggboxplot(modules$positive$metadata_modules,
      x = dependent,
      y = paste(i),
      add = "jitter",
      color = dependent
    ) +
      xlab(paste(dependent)) +
      ylab(paste("Eigen value in", i)) +
      theme_classic() +
      ggsignif::geom_signif() +
      scale_color_manual(values = c("#2E9FDF", "#E7B800"))
  }


  for (i in colnames(modules$negative$modules_eigen_value)) {
    boxplots$negative[[i]] <- ggpubr::ggboxplot(modules$negative$metadata_modules,
      x = dependent,
      y = paste(i),
      add = "jitter",
      color = dependent
    ) +
      xlab(paste(dependent)) +
      ylab(paste("Eigen value in", i)) +
      theme_classic() +
      ggsignif::geom_signif() +
      scale_color_manual(values = c("#2E9FDF", "#E7B800"))
  }




  ## Correlation heatmap
  correlation_heatmap <- correlation_heatmap_supervised(
    integrated_object = integrated_object,
    metadata = metadata,
    covariates = covariates
  )


  # ## Pseudo-time analysis
  # if (pseudotime_analysis == TRUE) {
  #   cli::cli_text("Pseudotime analysis...")
  #
  #   time_factor <- MOFA_get_pseudotime_factor(integrated_object, covariate = time)
  #   second_factor <- MOFA_get_relevant_factor(integrated_object, covariate = sense_check_variable)
  #
  #   clusters <- MOFA2::cluster_samples(integrated_object,
  #                                      k = 3,
  #                                      factors = c(time_factor, second_factor)
  #   )
  #   pseudotime <- pseudotime_inference(integrated_object,
  #                                      clusters,
  #                                      time_factor = time_factor,
  #                                      second_factor = second_factor,
  #                                      start.clus = 2,
  #                                      end.clus = 1,
  #                                      lineage = "Lineage1"
  #   )
  #
  #   integrated_object <- pseudotime$model
  #   module_trajectory <- list()
  #   module_trajectory$positive <- plot_module_trajectory(
  #     modules = modules$positive,
  #     covariates = covariates,
  #     plot_modules = names(modules$positive$modules_eigen_value)
  #   )
  #
  #   module_trajectory$negative <- plot_module_trajectory(
  #     modules = modules$negative,
  #     covariates = covariates,
  #     plot_modules = names(modules$negative$modules_eigen_value)
  #   )
  # }
  #


  ### Open targets
  cli::cli_text("Testing association of targets with disease of interest via the Open Targets API...")


  OpenTargets_results <- list()


  OpenTargets_results$positive$rna$df <- OpenTarget_dataframe(
    disease_id = disease_id,
    size = 1000,
    genes = signatures$positive$rna
  )

  OpenTargets_results$positive$rna$plot <- plot_OpenTarget(
    disease_id = disease_id,
    size = 1000,
    genes = signatures$positive$rna
  )

  OpenTargets_results$positive$protein$df <- OpenTarget_dataframe(
    disease_id = disease_id,
    size = 1000,
    genes = signatures$positive$protein
  )

  OpenTargets_results$positive$protein$plot <- plot_OpenTarget(
    disease_id = disease_id,
    size = 1000,
    genes = signatures$positive$protein
  )

  OpenTargets_results$negative$rna$df <- OpenTarget_dataframe(
    disease_id = disease_id,
    size = 1000,
    genes = signatures$negative$rna
  )

  OpenTargets_results$negative$rna$plot <- plot_OpenTarget(
    disease_id = disease_id,
    size = 1000,
    genes = signatures$negative$rna
  )

  OpenTargets_results$negative$protein$df <- OpenTarget_dataframe(
    disease_id = disease_id,
    size = 1000,
    genes = signatures$negative$protein
  )

  OpenTargets_results$negative$protein$plot <- plot_OpenTarget(
    disease_id = disease_id,
    size = 1000,
    genes = signatures$negative$protein
  )


  ## Track param
  parameters <- list(
    integration_model = integration_model,
    component=component,
    dependent = dependent,
    sense_check_variable = sense_check_variable,
    covariates = covariates,
    correlation_threshold = correlation_threshold,
    community_detection = community_detection,
    disease_id = disease_id
  )
  
  #### RESULTS OBJECT
  integrative_results <- list(
    direction_analysis = sign,
    variance = variance,
    correlation_heatmap = correlation_heatmap,
    weights = loadings,
    multiomic_networks = multiomic_networks,
    communities = communities_pos_neg,
    cell_type = cell_type,
    functional_enrichment = enrichment,
    TF = TF,
    modules = modules,
    OpenTargets = OpenTargets_results,
    analysis_parameters = parameters
  )

  MultiAssayExperiment::metadata(multiassay)$integrative_results[[integration_model]] <- integrative_results
  return(multiassay)
}


#' Downstream analysis for integrated multi-omics data
#'
#' @param multiassay Multiassay experiment object generated by Omix
#' @param integration_model Possible unsupervised integration methods are `DIABLO`, `sMBPLS`
#' @param dependent Dependent variable for groups.
#' @param correlation_threshold Absolute correlation threshold to draw edges
#' in the network
#' @param disease_id OpenTargets disease id. Default to "MONDO_0004975"
#' (Alzheimer's Disease) Different disease ontologies can be found on
#' https://www.ebi.ac.uk/ols/ontologies
#' @param sense_check_variable sense check
#' @param covariates cov
#' @param community_detection community detection method
#' @param TF_fp GMT file path with Transcription Factors and target genes
#' @param component Component to extract the multi-omics signature from
#' @param weights_threshold Threshold for loadings (weight)
#'
#' @return List object of integrated results
#'
#' @family Multi-omic integration downstream analysis
#' @import dplyr
#' @importFrom purrr possibly
#' @importFrom clusterProfiler enrichGO compareCluster
#' @importFrom enrichplot pairwise_termsim
#' @importFrom org.Hs.eg.db org.Hs.eg.db
#' @importFrom MOFA2 get_weights correlate_factors_with_covariates plot_variance_explained
#' @export

integrative_results_supervised <- function(multiassay,
                                            integration_model = "MBPLS",
                                            dependent = "PHF1",
                                            component = 1,
                                            sense_check_variable = "PHF1",
                                            covariates = c("PHF1", "amyloid", "AT8"),
                                            correlation_threshold = 0.5,
                                            weights_threshold = 0.8,
                                            community_detection = "leading_eigen",
                                            disease_id = "MONDO_0004975",
                                           TF_fp) {
  cli::cli_h2("Generating integrative muti-omics results ")

  integrated_object <- multiassay@metadata$integration[[integration_model]]
  variance <- data.frame(t(do.call(rbind, integrated_object$prop_expl_var)))
  variance$mRNA <- signif(variance$mRNA, 3)
  variance$proteins <- signif(variance$proteins, 3)
  metadata <- multiassay@metadata[["multimodal_object"]][["metadata"]]


  ## Sign
  cli::cli_text("Retrieving multi-omics signatures...")
  args <- list(
    integrated_object = integrated_object,
    metadata =  metadata,
    covariate = dependent,
    relevant_component = "comp1"
  )
  sign <- do.call(sign_signature, args)


  ## Multi-omics network
  args <- list(
    integrated_object = integrated_object,
    metadata = metadata,
    component = component,
    sense_check_variable =  sense_check_variable ,
    threshold=weights_threshold
  )

  # cli::cli_text("Retrieving weights...")
  loadings <- do.call(extract_loadings, args)

  cli::cli_text("Generating multi-omics network...")
  multiomic_networks <- list()
  multiomic_networks$positive <- multiomics_network(
    multiassay = multiassay,
    list =  loadings$weights$ranked_weights_positive,
    correlation_threshold = correlation_threshold
  )

  multiomic_networks$negative <- multiomics_network(
    multiassay = multiassay,
    list =loadings$weights$ranked_weights_negative,
    correlation_threshold = correlation_threshold
  )


  ## Network communities detection
  cli::cli_text("Detecting network communities...")
  communities_pos_neg <- list()
  communities_pos_neg$positive <- communities_network(
    igraph = multiomic_networks$positive$graph,
    community_detection = community_detection
  )
  communities_pos_neg$negative <- communities_network(
    igraph = multiomic_networks$negative$graph,
    community_detection = community_detection
  )


  ## Cell type enrichment
  cli::cli_text("Cell type enrichment of communities...")

  cell_type <- list()
  cell_type$positive <- cell_type_enrichment(
    multiassay = multiassay,
    communities = lapply(communities_pos_neg$positive$communities, function(x) {
      sub("\\_.*", "", x)
    })
  )
  cell_type$negative <- cell_type_enrichment(
    multiassay = multiassay,
    communities = lapply(communities_pos_neg$negative$communities, function(x) {
      sub("\\_.*", "", x)
    })
  )


  ## Functional enrichment
  cli::cli_text("Functional enrichment of communities...")

  communities_positive <- lapply(communities_pos_neg$positive$communities, function(x) {
    sub("\\_.*", "", x)
  })
  communities_negative <- lapply(communities_pos_neg$negative$communities, function(x) {
    sub("\\_.*", "", x)
  })

  enrichment <- list()
  enrichment$positive <- lapply(communities_positive, pathway_analysis_enrichr)
  enrichment$negative <- lapply(communities_negative, pathway_analysis_enrichr)


  ## Transcription Factor enrichment
  cli::cli_text("Transcription factor - target gene enrichment in communities...")

  TF <- list()
  TF$positive <- Transcription_Factor_enrichment_supervised(
    multiassay=multiassay,
    communities = communities_pos_neg$positive$communities,
    TF_gmt = TF_fp,
    direction = "positive",
    signatures = loadings$weights$ranked_weights_positive
  )

  TF$negative <- Transcription_Factor_enrichment_supervised(
    multiassay,
    communities = communities_pos_neg$negative$communities,
    TF_gmt = TF_fp,
    direction = "negative",
    signatures = loadings$weights$ranked_weights_negative
  )

  ## Multi-omics modules (eigenvalue)
  cli::cli_text("Computing module eigen expression for communities...")

  modules <- list()

  modules$positive <- multiomics_modules(
    multiassay = multiassay,
    metadata = metadata,
    covariates = covariates,
    communities = communities_pos_neg$positive$communities
  )

  modules$negative <- multiomics_modules(
    multiassay = multiassay,
    metadata = metadata,
    covariates = covariates,
    communities = communities_pos_neg$negative$communities
  )

  boxplots <- list()
  for (i in colnames(modules$positive$modules_eigen_value)) {
    boxplots$positive[[i]] <- ggpubr::ggboxplot(modules$positive$metadata_modules,
                                                x = dependent,
                                                y = paste(i),
                                                add = "jitter",
                                                color = dependent
    ) +
      xlab(paste(dependent)) +
      ylab(paste("Eigen value in", i)) +
      theme_classic() +
      ggsignif::geom_signif() +
      scale_color_manual(values = c("#2E9FDF", "#E7B800"))
  }


  for (i in colnames(modules$negative$modules_eigen_value)) {
    boxplots$negative[[i]] <- ggpubr::ggboxplot(modules$negative$metadata_modules,
                                                x = dependent,
                                                y = paste(i),
                                                add = "jitter",
                                                color = dependent
    ) +
      xlab(paste(dependent)) +
      ylab(paste("Eigen value in", i)) +
      theme_classic() +
      ggsignif::geom_signif() +
      scale_color_manual(values = c("#2E9FDF", "#E7B800"))
  }




  ## Correlation heatmap
  correlation_heatmap <- correlation_heatmap_supervised(
    integrated_object = integrated_object,
    metadata = metadata,
    covariates = covariates
  )


  # ## Pseudo-time analysis
  # if (pseudotime_analysis == TRUE) {
  #   cli::cli_text("Pseudotime analysis...")
  #
  #   time_factor <- MOFA_get_pseudotime_factor(integrated_object, covariate = time)
  #   second_factor <- MOFA_get_relevant_factor(integrated_object, covariate = sense_check_variable)
  #
  #   clusters <- MOFA2::cluster_samples(integrated_object,
  #                                      k = 3,
  #                                      factors = c(time_factor, second_factor)
  #   )
  #   pseudotime <- pseudotime_inference(integrated_object,
  #                                      clusters,
  #                                      time_factor = time_factor,
  #                                      second_factor = second_factor,
  #                                      start.clus = 2,
  #                                      end.clus = 1,
  #                                      lineage = "Lineage1"
  #   )
  #
  #   integrated_object <- pseudotime$model
  #   module_trajectory <- list()
  #   module_trajectory$positive <- plot_module_trajectory(
  #     modules = modules$positive,
  #     covariates = covariates,
  #     plot_modules = names(modules$positive$modules_eigen_value)
  #   )
  #
  #   module_trajectory$negative <- plot_module_trajectory(
  #     modules = modules$negative,
  #     covariates = covariates,
  #     plot_modules = names(modules$negative$modules_eigen_value)
  #   )
  # }
  #


  ### Open targets
  cli::cli_text("Testing association of targets with disease of interest via the Open Targets API...")


  OpenTargets_results <- list()


  OpenTargets_results$positive$rna$df <- OpenTarget_dataframe(
    disease_id = disease_id,
    size = 1000,
    genes = loadings$weights$ranked_weights_positive$rna
  )

  OpenTargets_results$positive$rna$plot <- plot_OpenTarget(
    disease_id = disease_id,
    size = 1000,
    genes = loadings$weights$ranked_weights_positive$rna
  )

  OpenTargets_results$positive$protein$df <- OpenTarget_dataframe(
    disease_id = disease_id,
    size = 1000,
    genes = loadings$weights$ranked_weights_positive$protein
  )

  OpenTargets_results$positive$protein$plot <- plot_OpenTarget(
    disease_id = disease_id,
    size = 1000,
    genes = loadings$weights$ranked_weights_positive$protein
  )

  OpenTargets_results$negative$rna$df <- OpenTarget_dataframe(
    disease_id = disease_id,
    size = 1000,
    genes = loadings$weights$ranked_weights_negative$rna
  )

  OpenTargets_results$negative$rna$plot <- plot_OpenTarget(
    disease_id = disease_id,
    size = 1000,
    genes = loadings$weights$ranked_weights_negative$rna
  )

  OpenTargets_results$negative$protein$df <- OpenTarget_dataframe(
    disease_id = disease_id,
    size = 1000,
    genes = loadings$weights$ranked_weights_negative$protein
  )

  OpenTargets_results$negative$protein$plot <- plot_OpenTarget(
    disease_id = disease_id,
    size = 1000,
    genes = loadings$weights$ranked_weights_negative$protein
  )


  ## Track param
  parameters <- list(
    integration_model = integration_model,
    component=component,
    dependent = dependent,
    sense_check_variable = sense_check_variable,
    covariates = covariates,
    weights_threshold = weights_threshold,
    correlation_threshold = correlation_threshold,
    community_detection = community_detection,
    disease_id = disease_id
  )

  #### RESULTS OBJECT
  integrative_results <- list(
    direction_analysis = sign,
    variance = variance,
    correlation_heatmap = correlation_heatmap,
    weights = loadings,
    multiomic_networks = multiomic_networks,
    communities = communities_pos_neg,
    cell_type = cell_type,
    functional_enrichment = enrichment,
    TF = TF,
    modules = modules,
    OpenTargets = OpenTargets_results,
    analysis_parameters = parameters
  )

  MultiAssayExperiment::metadata(multiassay)$integrative_results[[integration_model]] <- integrative_results
  return(multiassay)
}

#' Extract sign
#'
#' @param integrated_object integrated object
#' @param covariate covariates
#' @param relevant_component component
#'
#' @return Sign
#' @family Multi-omic integration downstream analysis
#' @export
#'
sign_signature <- function(integrated_object,
                           metadata,
                           covariate = "pTau",
                           relevant_component = "comp1") {
  pr <- integrated_object$variates$Y[, relevant_component]
  metadata <- metadata[, covariate]

  metadata <- sapply(metadata, as.numeric)
  mat <- stats::cor(cbind(pr, metadata),
    method = c("pearson"),
    use = "pairwise.complete.obs"
  )
  sign <- sign(mat["pr", "metadata"])
  return(sign)
}

#' Transcription factor target enrichment test
#'
#' @param communities communities slot generated generated by
#' `communities_network`
#' @param direction string indicating direction as "positive" or "negative"
#' @param multiassay multiassay
#' @param signatures signatures
#' @param TF_gmt GMT file with Transcription Factors and target genes
#'
#' @return TF target enrichment in each modules
#'
#' @family Multi-omic integration downstream analysis
#'
#' @importFrom ActivePathways read.GMT
#' @importFrom GeneOverlap drawHeatmap newGOM
#'
#' @export
#'
Transcription_Factor_enrichment_supervised <- function(multiassay,
                                                       communities,
                                                       signatures,
                                                       TF_gmt = "Enrichr_Queries.gmt",
                                                       direction = "negative") {
  TF_genelist <- ActivePathways::read.GMT(TF_gmt)
  TF_genelist_list <- lapply(TF_genelist, function(x) {
    x$genes
  })

  if (direction == "negative") {
    TF_targets <- signatures$negative$protein
  } else {
    TF_targets <- signatures$positive$protein
  }

  TF_focus <- intersect(names(TF_genelist_list), TF_targets)
  new <- TF_genelist_list[TF_focus]

  # filtering targets present in the RNA features
  metadata <- multiassay@metadata[["multimodal_object"]]$omics$mRNA

  new <- lapply(new, function(x) {
    x[which(x %in% rownames(metadata))]
  })

  communities_rna <- lapply(communities, function(x) {
    x[grepl("_rna", x, fixed = TRUE)]
  })
  communities_rna <- lapply(communities_rna, function(x) {
    sub("\\_.*", "", x)
  })
  names(communities_rna) <- paste0("ME", names(communities_rna))
  if(length(communities_rna)>=2){
  gom.obj <- GeneOverlap::newGOM(communities_rna, new, genome.size = nrow(metadata))
  }else{ gom.obj<- NULL}
  return(gom.obj)
}


#' Plot components
#'
#' @param integrated_object integrated object
#' @param metadata metadata
#' @param layer "mRNA", "proteins"
#' @param dependent dependent variable
#'
#' @return Plot
#' @family Plotting 

#' @export
#'

plot_components <- function(integrated_object,
                            metadata,
                            dependent,
                            layer = c("mRNA", "proteins")) {
  plot_data <- cbind(
    integrated_object$variates[[layer]][, c("comp1", "comp2")],
    multiassay@metadata[["multimodal_object"]]$metadata
  )

  ggpubr::ggscatter(plot_data,
    x = "comp1",
    y = "comp2",
    color = dependent,
    ellipse = TRUE, mean.point = TRUE,
    star.plot = TRUE
  ) + ggtitle(paste("Omic layer - ", layer))
}



###

#' Extract loadings
#'
#' @param sense_check_variable default to `NULL`. High weights should
#' coincide with stronger correlation if the sense_check_variable is an
#' important driver of variation in the designated factor. Will be used to
#' generate a plot if set to a covariate.
#' @param integrated_object integrated_object
#' @param metadata metadata
#' @param component component
#' @param threshold Absolute threshold to filter weights
#'
#' @return List with positive and negative weights above and below the
#' specified threshold, distirbution plots of the weights, and dataframes
#' of the weights for each omic layer.
#'
#' @family Multi-omic integration downstream analysis
#'
#' @importFrom dplyr %>% arrange desc filter pull
#' @importFrom ggpubr ggscatter
#' @importFrom viridis scale_color_viridis
#' @import ggplot2
#'
#' @export
#'
extract_loadings <- function(integrated_object,
                             metadata,
                             component = 1,
                             sense_check_variable = NULL,
                             threshold=0.2) {
  rna_1 <- data.frame(loadings = integrated_object$loadings$mRNA[, component])
  protein_1 <- data.frame(loadings = integrated_object$loadings$proteins[, component])

  rna_1$Row.names <- sub("\\_.*", "", rownames(rna_1))
  protein_1$Row.names <- sub("\\_.*", "", rownames(protein_1))

  colnames(rna_1) <- c("Weights", "Feature")
  colnames(protein_1) <- c("Weights", "Feature")

  rna_1$Weights= rna_1$Weights/max(abs( rna_1$Weights))
  protein_1$Weights=   protein_1$Weights/max(abs(  protein_1 $Weights))



  rna_1$model_feature <- rownames(rna_1)
  protein_1$model_feature <- rownames(protein_1)

  protein_positive <- protein_1 %>%
    dplyr::arrange(dplyr::desc(Weights), dplyr::desc(Feature)) %>%
    dplyr::filter(Weights >= threshold) %>%
    dplyr::pull(Feature)

  rna_positive <- rna_1 %>%
    dplyr::arrange(dplyr::desc(Weights), dplyr::desc(Feature)) %>%
    dplyr::filter(Weights >= threshold) %>%
    dplyr::pull(Feature)

  protein_negative <- protein_1 %>%
    dplyr::arrange(dplyr::desc(Weights), dplyr::desc(Feature)) %>%
    dplyr::filter(Weights <= -threshold) %>%
    dplyr::pull(Feature)

  rna_negative <- rna_1 %>%
    dplyr::arrange(dplyr::desc(Weights), dplyr::desc(Feature)) %>%
    dplyr::filter(Weights <= -threshold) %>%
    dplyr::pull(Feature)

  Weights_up <- list(
    rna = unique(rna_positive),
    protein = unique(protein_positive)
  )
  Weights_down <- list(
    rna = unique(rna_negative),
    protein = unique(protein_negative)
  )

  rna_1 <- rna_1 %>%
    dplyr::arrange(dplyr::desc(Weights), dplyr::desc(Feature))

  protein_1 <- protein_1 %>%
    dplyr::arrange(dplyr::desc(Weights), dplyr::desc(Feature))

  ## Check distribution
  distrib_rna <- ggplot2::ggplot(rna_1, aes(x = Weights)) +
    geom_density() +
    theme_classic() +
    ylab("Density of RNA weights")

  distrib_protein <- ggplot2::ggplot(protein_1, aes(x = Weights)) +
    geom_density() +
    theme_classic() +
    ylab("Density of Proteins weights")


  ggplot2::ggplot(protein_1, aes(x = correlation)) +
    geom_density() +
    theme_classic() +
    ylab("Density of Proteins weights")


  distrib_rna <- ggplot2::ggplot(rna_1, aes(x = Weights)) +
    geom_density() +
    theme_classic() +
    geom_vline(
      xintercept = threshold,
      linetype = "dotted",
      color = "blue",
      linewidth = 0.8
    ) +
    geom_vline(
      xintercept = -threshold, linetype = "dotted",
      color = "blue", linewidth = 0.8
    ) +
    ylab("Density of RNA weights")

  distrib_protein <- ggplot2::ggplot(protein_1, aes(x = Weights)) +
    geom_density() +
    theme_classic() +
    geom_vline(
      xintercept = threshold,
      linetype = "dotted",
      color = "blue",
      linewidth = 0.8
    ) +
    geom_vline(
      xintercept = -threshold, linetype = "dotted",
      color = "blue", size = 0.8
    ) +
    ylab("Density of Proteins weights")


  #### Check weight/correlation to sense check variable
  model <- integrated_object

  if (!is.null(sense_check_variable)) {
    t_p <- data.frame(model$X$proteins)
    cor_p <- stats::cor(metadata[, sense_check_variable], t_p,
                        use = "pairwise.complete.obs"
    )
    protein_1$Correlation <- cor_p[match(
      protein_1$Feature,
      colnames(cor_p)
    )]

    t_r <- data.frame(model$X$mRNA)
    cor_r <- stats::cor(metadata[, sense_check_variable], t_r,
                        use = "pairwise.complete.obs"
    )
    rna_1$Correlation <- cor_r[match(
      rna_1$Feature,
      colnames(cor_r)
    )]

    cor_weights_rna <- ggpubr::ggscatter(
      rna_1,
      "Weights",
      "Correlation"
    ) + ggplot2::geom_vline(
      xintercept = c(-threshold, threshold),
      linetype = "dotted",
      color = "blue",
      linewidth = 0.8
    ) +
      ggplot2::geom_hline(
        yintercept = c(-threshold, threshold),
        linetype = "dotted",
        color = "blue",
        linewidth = 0.8
      ) +
      viridis::scale_color_viridis() +
      ggplot2::ylab(paste(
        "Correlation of each transcript with",
        sense_check_variable
      ))

    cor_weights_protein <- ggpubr::ggscatter(
      protein_1,
      "Weights",
      "Correlation"
    ) + ggplot2::geom_vline(
      xintercept = c(-threshold, threshold),
      linetype = "dotted",
      color = "blue",
      linewidth = 0.8
    ) +
      ggplot2::geom_hline(
        yintercept = c(-threshold, threshold),
        linetype = "dotted",
        color = "blue",
        linewidth = 0.8
      ) +
      viridis::scale_color_viridis() +
      ggplot2::ylab(paste(
        "Correlation of each protein with",
        sense_check_variable
      ))
  }

  if (!is.null(sense_check_variable)) {
    return(result = list(
      weights = list(
        ranked_weights_positive = Weights_up,
        ranked_weights_negative = Weights_down
      ),
      distribution_plot = list(
        rna = distrib_rna,
        protein = distrib_protein
      ),
      weights_cor_plot = list(
        rna = cor_weights_rna,
        protein = cor_weights_protein
      ),
      weights_df = list(
        rna = rna_1,
        protein = protein_1
      )
    ))
  }

  if (is.null(sense_check_variable)) {
    return(result = list(
      weights = list(
        ranked_weights_positive = Weights_up,
        ranked_weights_negative = Weights_down
      ),
      distribution_plot = list(
        rna = distrib_rna,
        protein = distrib_protein
      ),
      weights_df = list(
        rna = rna_1,
        protein = protein_1
      )
    ))
  }
}


#' Plot loadings
#'
#' @param loadings loadings
#' @param layer `rna` or `proteins`
#' @param sign `positive` or `negative`
#' @param abs TRUE
#' @param nfeatures number of features to plot
#'
#' @return Plot of top feature loadings
#' @family Plotting 
#' @export
#'

plot_loadings <- function(loadings = loadings$weights_df,
                          layer = "rna",
                          sign = NULL,
                          abs = TRUE,
                          nfeatures = 30) {
  # Store sign
  W <- loadings[[layer]]
  W <- W[W$Weights != 0, ]
  W$sign <- ifelse(W$Weights > 0, "+", "-")

  # Select subset of only positive or negative weights
  if (sign == "positive") {
    W <- W[W$Weights > 0, ]
  } else if (sign == "negative") {
    W <- W[W$Weights < 0, ]
  }

  # Absolute value
  if (abs) W$Weights <- abs(W$Weights)

  # Extract relevant features
  W <- W[with(W, order(-abs(Weights))), ]

  # Sort according to weights for each factor
  W <- as.data.frame(top_n(W, n = nfeatures, wt = Weights))
  #

  # Make features names unique
  W$feature_id <- W$Feature
  # In order to re-order features across multiple factors,
  # make them unique for different factors
  W$feature_id <- factor(W$feature_id, levels = rev(unique(W$feature_id)))

  p <- ggplot(W, aes(x = .data$feature_id, y = .data$Weights)) +
    geom_point(size = 2) +
    geom_segment(aes(xend = .data$feature_id), linewidth = 0.75, yend = 0) +
    scale_colour_gradient(low = "grey", high = "black") +
    coord_flip() +
    labs(y = "Weight") +

    # Theme
    theme_bw() +
    theme(
      axis.title.x = element_text(color = "black"),
      axis.title.y = element_blank(),
      axis.text.y = element_text(size = rel(1.1), hjust = 1, color = "black"),
      axis.text.x = element_text(color = "black"),
      axis.ticks.y = element_blank(),
      axis.ticks.x = element_line(),
      legend.position = "top",
      legend.title = element_blank(),
      legend.text = element_text(color = "black"),
      legend.key = element_rect(fill = "transparent"),

      # facets
      strip.text = element_text(size = rel(1.2)),
      panel.background = element_blank(),
      panel.spacing = unit(1, "lines"),

      # gridlines
      panel.grid.major.y = element_blank(),
    )
  if (sign == "negative") p <- p + scale_x_discrete(position = "top")

  # If absolute values are used, add the corresponding signs to the plot
  if (abs) {
    p <- p +
      ylim(0, max(W$Weights) + 0.1) +
      geom_text(label = W$sign, y = max(W$Weights) + 0.1, size = 8)
  }

  return(p)
}
