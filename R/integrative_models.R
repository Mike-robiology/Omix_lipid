#' Vertical integration with DIABLO including model tuning
#'
#' @param multimodal_omics multimodal_object generated by `get_multimodal_object`
#' @param Y Outcome variable
#' @param ncomp Number of components
#' @param design Available options are cor, full. Possible designs for
#' integration are `cor`(strength of correlation between PC1 of omics layers)
#' or `full` (The strength of all relationships between dataframes is
#' maximised (= 1) – a “fully connected” design)
#' @param range a named list specifying the number of rna and protein.
#' @param list.keepX list to keep rows
#'
#' @return a list object with `multimodal_object` and `model` slots
#'
#' @family Multi-omic integration
#'
#' @importFrom MultiAssayExperiment MultiAssayExperiment listToMap colData
#'  getWithColData sampleMap
#' @importFrom mixOmics block.splsda tune.block.splsda
#' @export
#'

integrate_with_DIABLO <- function(multimodal_omics,
                                  Y,
                                  ncomp,
                                  design,
                                  range = list(
                                    mRNA = seq(5, 100, by = 10),
                                    proteins = seq(5, 100, by = 10)
                                  ),
                                  list.keepX) {
  multimodal_omics <- lapply(multimodal_omics, t)
  X <- list(
    mRNA = multimodal_omics[[1]],
    proteins = multimodal_omics[[2]]
  )


  A <- X$mRNA
  B <- X$proteins

  if (design == "cor") {
    Apca <- prcomp(A, rank. = 1)
    Bpca <- prcomp(B, rank. = 1)
    cor <- cor(Apca$x, Bpca$x)

    design <- matrix(cor,
      ncol = length(X), nrow = length(X),
      dimnames = list(names(X), names(X))
    )
    diag(design) <- 0
  } else if (design == "full") {
    design <- "full"
  }


  Y <- factor(Y)
  cli::cli_h2("MODEL TUNING")
  tune <- suppressWarnings({
    mixOmics::tune.block.splsda(
      X = X,
      Y = Y,
      ncomp = ncomp,
      design = design,
      test.keepX = list(
        "mRNA" = range[[1]],
        "proteins" = range[[2]]
      ),
      validation = "Mfold",
      folds = 5,
      nrepeat = 1,
      progressBar = TRUE
    )
  })

  list.keepX <- tune$choice.keepX
  tuned.diablo <- suppressWarnings({
    mixOmics::block.splsda(
      X = X,
      Y = Y,
      keepX = list.keepX,
      ncomp = ncomp,
      design = design,
      scale = TRUE
    )
  })

  model <- tuned.diablo
  X <- lapply(X, t)

  return(list(
    multimodal_object = X,
    model = model
  ))
}

#' Vertical integration with SMBPLS
#'
#' @param multimodal_omics multimodal_object generated by `get_multimodal_object`
#' @param Y Outcome variable
#' @param design Available values are cor, full, avg. Possible designs for
#' integration are `cor`(strength of correlation between PC1 of omics layers)
#' or `full` (The strength of all relationships between dataframes is maximised
#' (= 1) – a “fully connected” design)
#' @param ncomp Number of components
#' @param list.keepX grid of keepX values to keep in the tuning phase
#'
#' @return a list object with `multimodal_object` and `model` slots
#'
#' @family Multi-omic integration
#'
#' @importFrom mixOmics block.spls
#' @export
#'

integrate_with_sMBPLS <- function(multimodal_omics,
                                  Y,
                                  design,
                                  ncomp,
                                  list.keepX = list(mRNA = c(50),
                                                    proteins = c(50))
                                  ) {
  multimodal_omics <- lapply(multimodal_omics, t)
  X <- list(
    mRNA = multimodal_omics[[1]],
    proteins = multimodal_omics[[2]]
  )

  A <- multimodal_omics[[1]]
  B <- multimodal_omics[[2]]
  if (design == "cor") {
    Apca <- prcomp(A, rank. = 1)
    Bpca <- prcomp(B, rank. = 1)
    cor <- cor(Apca$x, Bpca$x)

    design <- matrix(cor,
      ncol = length(X), nrow = length(X),
      dimnames = list(names(X), names(X))
    )
    diag(design) <- 0

    design <- matrix(cor,
      ncol = length(X), nrow = length(X),
      dimnames = list(names(X), names(X))
    )
    diag(design) <- 0
  } else if (design == "avg") {
    design <- matrix(0.3,
      ncol = length(X), nrow = length(X),
      dimnames = list(names(X), names(X))
    )
    diag(design) <- 0
  } else {
    design <- "full"
  }

  tuned.diablo <- mixOmics::block.spls(
    X = X,
    Y = Y,
    keepX = list.keepX,
    ncomp = ncomp,
    design = design
  )
  model <- tuned.diablo
  X <- lapply(X, t)


  return(list(
    multimodal_object = X,
    model = model
  ))
}


#' Vertical integration with MBPLS
#'
#' @param multimodal_omics  multimodal_object generated by `get_multimodal_object`
#' @param Y Outcome variable
#' @param design Available values are cor, full, avg. Possible designs for
#' integration are `cor`(strength of correlation between PC1 of omics layers)
#' or `full` (The strength of all relationships between dataframes is maximised
#' (= 1) – a “fully connected” design)
#' @param ncomp Number of components
#'
#' @return a list object with `multimodal_object` and `model` slots
#'
#' @family Multi-omic integration
#'
#' @importFrom mixOmics block.pls
#' @export
#'

integrate_with_MBPLS <- function(multimodal_omics,
                                 Y,
                                 design,
                                 ncomp) {
  multimodal_omics <- lapply(multimodal_omics, t)
  X <- list(
    mRNA = multimodal_omics[[1]],
    proteins = multimodal_omics[[2]]
  )

  A <- multimodal_omics[[1]]
  B <- multimodal_omics[[2]]
  if (design == "cor") {
    Apca <- prcomp(A, rank. = 1)
    Bpca <- prcomp(B, rank. = 1)
    cor <- cor(Apca$x, Bpca$x)

    design <- matrix(cor,
      ncol = length(X), nrow = length(X),
      dimnames = list(names(X), names(X))
    )
    diag(design) <- 0

    design <- matrix(cor,
      ncol = length(X), nrow = length(X),
      dimnames = list(names(X), names(X))
    )
    diag(design) <- 0
  } else if (design == "avg") {
    design <- matrix(0.3,
      ncol = length(X), nrow = length(X),
      dimnames = list(names(X), names(X))
    )
    diag(design) <- 0
  } else {
    design <- "full"
  }
  tuned.diablo <- mixOmics::block.pls(
    X = X,
    Y = Y,
    ncomp = ncomp,
    design = design
  )
  model <- tuned.diablo
  X <- lapply(X, t)


  return(list(
    multimodal_object = X,
    model = model
  ))
}


#' Vertical integration with MOFA
#'
#' @param multimodal_omics  multimodal_object generated by `get_multimodal_object`
#' @param num_factors Number of factors
#' @param scale_views Logical whether to scale omics layers
#' @param metadata sample metadata
#'
#' @return a list object with `multimodal_object` and `model` slots
#'
#' @family Multi-omic integration
#'
#' @importFrom MOFA2 create_mofa get_default_data_options
#' get_default_model_options get_default_training_options prepare_mofa run_mofa
#' @export

integrate_with_MOFA <- function(multimodal_omics,
                                num_factors = 5,
                                scale_views = TRUE,
                                metadata) {
  python_path <- Sys.which("python")
  reticulate::use_python(python_path, required = NULL)

  X <- list(
    mRNA = multimodal_omics[[1]],
    proteins = multimodal_omics[[2]]
  )

  MOFAobject <- MOFA2::create_mofa(X)
  data_opts <- MOFA2::get_default_data_options(MOFAobject)
  data_opts$scale_views <- scale_views

  model_opts <- MOFA2::get_default_model_options(MOFAobject)
  model_opts$num_factors <- num_factors

  train_opts <- MOFA2::get_default_training_options(MOFAobject)
  train_opts$convergence_mode <- "medium"
  train_opts$seed <- 42
  train_opts$stochastic <- FALSE

  MOFAobject <- MOFA2::prepare_mofa(MOFAobject,
    data_options = data_opts,
    model_options = model_opts,
    training_options = train_opts
  )

  MOFAobject <- MOFA2::run_mofa(MOFAobject, use_basilisk = TRUE)
  metadata$sample <- rownames(metadata)
  MOFA2::samples_metadata(MOFAobject) <- metadata
  model <- MOFAobject


  return(list(
    multimodal_object = X,
    model = model
  ))
}


#' Vertical integration with MEIFESTO
#'
#' @param multimodal_omics multimodal_object generated by `get_multimodal_object`
#' @param num_factors Number of factors
#' @param scale_views Logical whether to scale omics layers
#' @param metadata metadata object generated by `get_multimodal_object`
#' @param time Time covariates
#'
#' @return a list object with `multimodal_object` and `model` slots
#'
#' @family Multi-omic integration
#'
#' @importFrom MOFA2 create_mofa get_default_data_options
#' get_default_model_options get_default_training_options prepare_mofa run_mofa
#' get_default_mefisto_options
#' @export
#'

integrate_with_MEIFESTO <- function(multimodal_omics,
                                    num_factors = 5,
                                    scale_views = TRUE,
                                    metadata,
                                    time = "pseudotime"
                                    ) {
  # python_path <- Sys.which("python")
  # reticulate::use_python(python_path, required = NULL)

  time <- metadata[, time]
  names(time) <- rownames(metadata)
  time <- data.frame(time)
  time <- t(time)

  X <- list(
    mRNA = multimodal_omics[[1]],
    proteins = multimodal_omics[[2]]
  )

  MOFAobject <- MOFA2::create_mofa(X)
  MOFAobject <- MOFA2::set_covariates(MOFAobject, covariates = time)
  data_opts <- MOFA2::get_default_data_options(MOFAobject)
  data_opts$scale_views <- scale_views

  model_opts <- MOFA2::get_default_model_options(MOFAobject)
  model_opts$num_factors <- num_factors


  train_opts <- MOFA2::get_default_training_options(MOFAobject)
  train_opts$seed <- 2020
  train_opts$maxiter <- 1000
  train_opts$convergence_mode <- "medium"

  mefisto_opts <- MOFA2::get_default_mefisto_options(MOFAobject)

  MOFAobject <- MOFA2::prepare_mofa(MOFAobject,
    data_options = data_opts,
    model_options = model_opts,
    training_options = train_opts,
    mefisto_options = mefisto_opts
  )

  MOFAobject <- MOFA2::run_mofa(MOFAobject, use_basilisk = TRUE)
  metadata$sample <- rownames(metadata)
  MOFA2::samples_metadata(MOFAobject) <- metadata
  model <- MOFAobject


  return(list(
    multimodal_object = X,
    model = model
  ))
}
