#' Vertical integration with DIABLO including model tuning
#'
#' @param multimodal_omics multimodal_object generated by `get_multimodal_object`
#' @param Y Outcome variable
#' @param ncomp Number of components
#' @param design Available options are cor, full. Possible designs for
#' integration are `cor`(strength of correlation between PC1 of omics layers)
#' or `full` (The strength of all relationships between dataframes is
#' maximised (= 1) – a “fully connected” design)
#' @param range a named list specifying the number of rna and protein.
#' @param list.keepX list to keep rows
#'
#' @return a list object with `multimodal_object` and `model` slots
#'
#' @family Multi-omic integration
#'
#' @importFrom MultiAssayExperiment MultiAssayExperiment listToMap colData
#'  getWithColData sampleMap
#' @importFrom mixOmics block.splsda tune.block.splsda
#' @export
#'

integrate_with_DIABLO <- function(multimodal_omics,
                                  Y,
                                  ncomp,
                                  design,
                                  range = list(
                                    mRNA = seq(5, 100, by = 10),
                                    proteins = seq(5, 100, by = 10)
                                  ),
                                  list.keepX) {
  multimodal_omics <- lapply(multimodal_omics, t)
  X <- list(
    mRNA = multimodal_omics[[1]],
    proteins = multimodal_omics[[2]]
  )


  A <- X$mRNA
  B <- X$proteins

  if (design == "cor") {
    Apca <- prcomp(A, rank. = 1)
    Bpca <- prcomp(B, rank. = 1)
    cor <- cor(Apca$x, Bpca$x)

    design <- matrix(cor,
      ncol = length(X), nrow = length(X),
      dimnames = list(names(X), names(X))
    )
    diag(design) <- 0
  } else if (design == "full") {
    design <- "full"
  }


  Y <- factor(Y)
  cli::cli_h2("MODEL TUNING")
  tune <- suppressWarnings({
    mixOmics::tune.block.splsda(
      X = X,
      Y = Y,
      ncomp = ncomp,
      design = design,
      test.keepX = list(
        "mRNA" = range[[1]],
        "proteins" = range[[2]]
      ),
      validation = "Mfold",
      folds = 5,
      nrepeat = 1,
      progressBar = TRUE
    )
  })

  list.keepX <- tune$choice.keepX
  tuned.diablo <- suppressWarnings({
    mixOmics::block.splsda(
      X = X,
      Y = Y,
      keepX = list.keepX,
      ncomp = ncomp,
      design = design,
      scale = TRUE
    )
  })

  model <- tuned.diablo
  X <- lapply(X, t)

  return(list(
    multimodal_object = X,
    model = model
  ))
}

#' Vertical integration with SMBPLS
#'
#' @param multimodal_omics multimodal_object generated by `get_multimodal_object`
#' @param Y Outcome variable
#' @param design Available values are cor, full, avg. Possible designs for
#' integration are `cor`(strength of correlation between PC1 of omics layers)
#' or `full` (The strength of all relationships between dataframes is maximised
#' (= 1) – a “fully connected” design)
#' @param ncomp Number of components
#' @param list.keepX grid of keepX values to keep in the tuning phase
#'
#' @return a list object with `multimodal_object` and `model` slots
#'
#' @family Multi-omic integration
#'
#' @importFrom mixOmics block.spls
#' @export
#'

integrate_with_sMBPLS <- function(multimodal_omics,
                                  Y,
                                  design,
                                  ncomp,
                                  list.keepX = list(
                                    mRNA = c(50),
                                    proteins = c(50)
                                  )) {
  multimodal_omics <- lapply(multimodal_omics, t)
  X <- list(
    mRNA = multimodal_omics[[1]],
    proteins = multimodal_omics[[2]]
  )

  A <- multimodal_omics[[1]]
  B <- multimodal_omics[[2]]
  if (design == "cor") {
    Apca <- prcomp(A, rank. = 1)
    Bpca <- prcomp(B, rank. = 1)
    cor <- cor(Apca$x, Bpca$x)

    design <- matrix(cor,
      ncol = length(X), nrow = length(X),
      dimnames = list(names(X), names(X))
    )
    diag(design) <- 0

    design <- matrix(cor,
      ncol = length(X), nrow = length(X),
      dimnames = list(names(X), names(X))
    )
    diag(design) <- 0
  } else if (design == "avg") {
    design <- matrix(0.3,
      ncol = length(X), nrow = length(X),
      dimnames = list(names(X), names(X))
    )
    diag(design) <- 0
  } else {
    design <- "full"
  }

  tuned.diablo <- mixOmics::block.spls(
    X = X,
    Y = Y,
    keepX = list.keepX,
    ncomp = ncomp,
    design = design
  )
  model <- tuned.diablo
  X <- lapply(X, t)


  return(list(
    multimodal_object = X,
    model = model
  ))
}


#' Vertical integration with MBPLS
#'
#' @param multimodal_omics  multimodal_object generated by `get_multimodal_object`
#' @param Y Outcome variable
#' @param design Available values are cor, full, avg. Possible designs for
#' integration are `cor`(strength of correlation between PC1 of omics layers)
#' or `full` (The strength of all relationships between dataframes is maximised
#' (= 1) – a “fully connected” design)
#' @param ncomp Number of components
#'
#' @return a list object with `multimodal_object` and `model` slots
#'
#' @family Multi-omic integration
#'
#' @importFrom mixOmics block.pls
#' @export
#'

integrate_with_MBPLS <- function(multimodal_omics,
                                 Y,
                                 design,
                                 ncomp) {
  multimodal_omics <- lapply(multimodal_omics, t)
  X <- list(
    mRNA = multimodal_omics[[1]],
    proteins = multimodal_omics[[2]]
  )

  A <- multimodal_omics[[1]]
  B <- multimodal_omics[[2]]
  if (design == "cor") {
    Apca <- prcomp(A, rank. = 1)
    Bpca <- prcomp(B, rank. = 1)
    cor <- cor(Apca$x, Bpca$x)

    design <- matrix(cor,
      ncol = length(X), nrow = length(X),
      dimnames = list(names(X), names(X))
    )
    diag(design) <- 0

    design <- matrix(cor,
      ncol = length(X), nrow = length(X),
      dimnames = list(names(X), names(X))
    )
    diag(design) <- 0
  } else if (design == "avg") {
    design <- matrix(0.3,
      ncol = length(X), nrow = length(X),
      dimnames = list(names(X), names(X))
    )
    diag(design) <- 0
  } else {
    design <- "full"
  }
  tuned.diablo <- mixOmics::block.pls(
    X = X,
    Y = Y,
    ncomp = ncomp,
    design = design
  )
  model <- tuned.diablo
  X <- lapply(X, t)


  return(list(
    multimodal_object = X,
    model = model
  ))
}


#' Vertical integration with MOFA
#'
#' @param multimodal_omics  multimodal_object generated by `get_multimodal_object`
#' @param num_factors Number of factors
#' @param scale_views Logical whether to scale omics layers
#' @param metadata sample metadata
#'
#' @return a list object with `multimodal_object` and `model` slots
#'
#' @family Multi-omic integration
#'
#' @importFrom MOFA2 create_mofa get_default_data_options
#' get_default_model_options get_default_training_options prepare_mofa run_mofa
#' @export

integrate_with_MOFA <- function(multimodal_omics,
                                num_factors = 5,
                                scale_views = TRUE,
                                metadata) {
  python_path <- Sys.which("python")
  reticulate::use_python(python_path, required = NULL)

  X <- list(
    mRNA = multimodal_omics[[1]],
    proteins = multimodal_omics[[2]]
  )

  MOFAobject <- MOFA2::create_mofa(X)
  data_opts <- MOFA2::get_default_data_options(MOFAobject)
  data_opts$scale_views <- scale_views

  model_opts <- MOFA2::get_default_model_options(MOFAobject)
  model_opts$num_factors <- num_factors

  train_opts <- MOFA2::get_default_training_options(MOFAobject)
  train_opts$convergence_mode <- "medium"
  train_opts$seed <- 42
  train_opts$stochastic <- FALSE

  MOFAobject <- MOFA2::prepare_mofa(MOFAobject,
    data_options = data_opts,
    model_options = model_opts,
    training_options = train_opts
  )

  MOFAobject <- MOFA2::run_mofa(MOFAobject, use_basilisk = TRUE)
  metadata$sample <- rownames(metadata)
  MOFA2::samples_metadata(MOFAobject) <- metadata
  model <- MOFAobject


  return(list(
    multimodal_object = X,
    model = model
  ))
}


#' Vertical integration with MEIFESTO
#'
#' @param multimodal_omics multimodal_object generated by `get_multimodal_object`
#' @param num_factors Number of factors
#' @param scale_views Logical whether to scale omics layers
#' @param metadata metadata object generated by `get_multimodal_object`
#' @param time Time covariates
#'
#' @return a list object with `multimodal_object` and `model` slots
#'
#' @family Multi-omic integration
#'
#' @importFrom MOFA2 create_mofa get_default_data_options
#' get_default_model_options get_default_training_options prepare_mofa run_mofa
#' get_default_mefisto_options
#' @export
#'

integrate_with_MEIFESTO <- function(multimodal_omics,
                                    num_factors = 5,
                                    scale_views = TRUE,
                                    metadata,
                                    time = "pseudotime") {
  # python_path <- Sys.which("python")
  # reticulate::use_python(python_path, required = NULL)

  time <- metadata[, time]
  names(time) <- rownames(metadata)
  time <- data.frame(time)
  time <- t(time)

  X <- list(
    mRNA = multimodal_omics[[1]],
    proteins = multimodal_omics[[2]]
  )

  MOFAobject <- MOFA2::create_mofa(X)
  MOFAobject <- MOFA2::set_covariates(MOFAobject, covariates = time)
  data_opts <- MOFA2::get_default_data_options(MOFAobject)
  data_opts$scale_views <- scale_views

  model_opts <- MOFA2::get_default_model_options(MOFAobject)
  model_opts$num_factors <- num_factors


  train_opts <- MOFA2::get_default_training_options(MOFAobject)
  train_opts$seed <- 2020
  train_opts$maxiter <- 1000
  train_opts$convergence_mode <- "medium"

  mefisto_opts <- MOFA2::get_default_mefisto_options(MOFAobject)

  MOFAobject <- MOFA2::prepare_mofa(MOFAobject,
    data_options = data_opts,
    model_options = model_opts,
    training_options = train_opts,
    mefisto_options = mefisto_opts
  )

  MOFAobject <- MOFA2::run_mofa(MOFAobject, use_basilisk = TRUE)
  metadata$sample <- rownames(metadata)
  MOFA2::samples_metadata(MOFAobject) <- metadata
  model <- MOFAobject


  return(list(
    multimodal_object = X,
    model = model
  ))
}

#' @name getClustNum
#' @title Get estimation of optimal clustering number
#' @description This function provides two measurements (i.e., clustering prediction index and Gap-statistics) and aims to search the optimal number for multi-omics integrative clustering. In short, the peaks reach by the red (CPI) and blue (Gap-statistics) lines should be referred to determine `N.clust`.
#' @param data List of matrices.
#' @param is.binary A logicial vector to indicate if the subdata is binary matrix of 0 and 1 such as mutation.
#' @param try.N.clust A integer vector to indicate possible choices of number of clusters.
#' @param center A logical value to indicate if the variables should be centered. TRUE by default.
#' @param scale A logical value to indicate if the variables should be scaled. FALSE by default.
#' @export
#' @return A figure that helps to choose the optimal clustering number (argument of `N.clust`), and a list containing the cluster number of  identified by clustering prediction index (CPI) and Gap statistics
#' @family Multi-omic integration
#' @importFrom IntNMF nmf.opt.k
#' @importFrom  mogsa mbpca moGap
#' @import SNFtool
#' @importFrom ggplot2 alpha
#' @importFrom dplyr %>%
#' @examples # There is no example and please refer to vignette.
#' @references Chalise P, Fridley BL (2017). Integrative clustering of multi-level omic data based on non-negative matrix factorization algorithm. PLoS One, 12(5):e0176278.
#'
#' Tibshirani, R., Walther, G., Hastie, T. (2001). Estimating the number of data clusters via the Gap statistic. J R Stat Soc Series B Stat Methodol, 63(2):411-423.
#'
getClustNum <- function(data = NULL,
                        is.binary = rep(FALSE, length(data)),
                        try.N.clust = 2:8,
                        center = TRUE,
                        scale = TRUE) {
  # check data
  n_dat <- length(data)
  if (n_dat > 2) {
    stop("current version of Omix can support up to 2 datasets.")
  }
  if (n_dat < 2) {
    stop("current version of Omix  needs at least 2 omics data.")
  }

  data.backup <- data # save a backup

  #--------------------------------------------#
  # Cluster Prediction Index (CPI) from IntNMF #
  # remove features that made of categories not equal to 2 otherwise Error in svd(X) : a dimension is zero
  if (!all(!is.binary)) {
    bindex <- which(is.binary == TRUE)
    for (i in bindex) {
      a <- which(rowSums(data[[i]]) == 0)
      b <- which(rowSums(data[[i]]) == ncol(data[[i]]))
      if (length(a) > 0) {
        data[[i]] <- data[[i]][which(rowSums(data[[i]]) != 0), ] # remove all zero
      }

      if (length(b) > 0) {
        data[[i]] <- data[[i]][which(rowSums(data[[i]]) != ncol(data[[i]])), ] # remove all one
      }

      if (length(a) + length(b) > 0) {
        message(paste0("--", names(data)[i], ": a total of ", length(a) + length(b), " features were removed due to the categories were not equal to 2!"))
      }
    }
  }

  # In order to make the input data fit non-negativity constraint of intNMF,
  # the values of the data were shifted to positive direction by adding absolute value of the smallest negative number.
  # Further, each data was rescaled by dividing by maximum value of the data to make the magnitudes comparable (between 0 and 1) across the several datasets.
  dat <- lapply(data, function(dd) {
    if (!all(dd >= 0)) dd <- pmax(dd + abs(min(dd)), 0) + .Machine$double.eps # .Machine$double.eps as The smallest positive floating-point number x
    dd <- dd / max(dd)
    return(dd %>% as.matrix())
  })

  # dat <- lapply(dat, t)
  dat <- lapply(dat, function(x) t(x) + .Machine$double.eps)

  message("calculating Cluster Prediction Index...")
  optk1 <- IntNMF::nmf.opt.k(
    dat = dat,
    n.runs = 5,
    n.fold = 5,
    k.range = try.N.clust,
    st.count = 10,
    maxiter = 100,
    make.plot = FALSE
  )
  optk1 <- as.data.frame(optk1)

  #-------------------------------#
  # Gap-statistics from MoCluster #
  message("calculating Gap-statistics...")
  moas <- data.backup %>% mogsa::mbpca(
    ncomp = 2,
    k = "all",
    method = "globalScore",
    center = center,
    scale = scale,
    moa = TRUE,
    svd.solver = "fast",
    maxiter = 1000,
    verbose = FALSE
  )
  gap <- mogsa::moGap(moas, K.max = max(try.N.clust), cluster = "hclust", plot = FALSE)
  optk2 <- as.data.frame(gap$Tab)[-1, ] # remove k=1


  N.clust <- as.numeric(which.max(apply(optk1, 1, mean) + optk2$gap)) + 1
  if (length(N.clust) == 0) {
    message("--fail to define the optimal cluster number!")
    N.clust <- "null"
  }


  if (N.clust > 1) {
    message(paste0("--the imputed optimal cluster number is ", N.clust, " arbitrarily, but it would be better referring to other priori knowledge."))
  }
  # return(list(N.clust = N.clust, CPI = optk1, Gapk = optk2, Eigen = optk3))
  return(list(N.clust = N.clust, CPI = optk1, Gapk = optk2))
}

#'  Vertical integration with iCluster
#'
#' @param multimodal_omics multimodal_object generated by `.get_multimodal_object`
#' @param try.N.clust Range of number of potential clusters in the optimisation step
#' @export
#'
#' @return a list object with `multimodal_object` and `model` slots
#'
#' @family Multi-omic integration
#' @importFrom iClusterPlus iClusterBayes

integrate_with_iCluster <- function(multimodal_omics,
                                    try.N.clust = 2:6) {
  cli::cli_alert_success("Optimising the number of cluster (this make take a while")

  args <- list(
    data = multimodal_omics,
    is.binary = c(F, F),
    try.N.clust = try.N.clust,
    center = TRUE,
    scale = TRUE)

  optk.i <- do.call(getClustNum, args)

  optimal_n <- optk.i$N.clust

  m1 <- t(multimodal_omics[[1]])
  m2 <- t(multimodal_omics[[2]])

  cli::cli_alert_success("Integration in progress (this make take a while)")
  model <- iClusterPlus::iClusterBayes(
    dt1 = m1,
    dt2 = m2,
    dt3 = NULL, dt4 = NULL, dt5 = NULL, dt6 = NULL,
    type = c("gaussian", "gaussian"),
    K = optimal_n - 1,
    n.burnin = 1000,
    n.draw = 1200,
    prior.gamma = rep(0.1, 6),
    sdev = 0.5,
    beta.var.scale = 1,
    thin = 1,
    pp.cutoff = 0.5
  )
  return(list(
    multimodal_object = multimodal_omics,
    model = model,
    tuning = list(
      optk.i = optk.i,
      try.N.clust = try.N.clust
    )
  ))
}

