#' Get multiomics networks from multimodal object
#'
#' @param multimodal_object multimodal_object generated by `get_multimodal_object`
#' @param list Named list of processed omic slots and features of interest
#' @param correlation_threshold Absolute correlation threshold to draw edges
#' in the network
#'
#' @return List containing `graph` and `matrix` slots
#'
#' @family Plotting
#'
#' @import igraph
#' @export
#'

multiomics_network_matrix <- function(multimodal_object,
                                       list,
                                       correlation_threshold = 0.5) {
  features_interest <- c(list[[1]], list[[2]])
  pk <- c(length(list[[1]]), length(list[[2]]))

  matrix1 <- t(multimodal_object[[1]])
  matrix1 <- matrix1[, list[[1]]]


  matrix2 <- t(multimodal_object[[2]])
  matrix2 <- matrix2[, list[[2]]]

  matrix <- scale(cbind(matrix1, matrix2))
  colnames(matrix) <- features_interest

  colnames(matrix)[1:pk[1]] <- paste0(colnames(matrix)[1:pk[1]], "_rna")
  colnames(matrix)[(pk[1] + 1):(pk[1] + pk[2])] <- paste0(
    colnames(matrix)[(pk[1] + 1):(pk[1] + pk[2])], "_protein")

  rho <- stats::cor(matrix)
  thr_cor <- correlation_threshold
  rho <- ifelse(abs(rho) >= thr_cor, yes = rho, no = 0)


  rho[rho < correlation_threshold] <- 0
  diag(rho) <- 0
  mygraph <- igraph::graph.adjacency(rho, weighted = TRUE, mode = "lower")


  a <- apply(rho, 1, function(x) {
    .color.gradient(x)
  })
  rownames(a) <- colnames(a)


  mynode_colours <- c(rep("#B39DDB", pk[1]), rep("#00796B", pk[2]))
  mynode_labels <- colnames(matrix)

  igraph::V(mygraph)$label <- mynode_labels
  igraph::V(mygraph)$color <- mynode_colours
  igraph::V(mygraph)$label.family <- "sans"
  igraph::V(mygraph)$label.color <- "grey20"
  igraph::E(mygraph)$weight
  igraph::V(mygraph)$label.cex <- 0.5
  set.seed(1)

  list <- list(
    graph = mygraph,
    matrix = matrix,
    hubs = hub_score(mygraph)$vector
  )
  return(list)
}


#' Get multiomics networks from multiassay object

#'
#' @param multiassay Multiassay experiment object generated by Omix
#' `generate_multiassay`function
#' @param list named list of processed omic slots and features of interest
#' @param correlation_threshold Absolute correlation threshold to draw edges
#' in the network
#'
#' @return List containing `graph` and `matrix` slots
#'
#' @family Plotting
#'
#' @import igraph
#'
#' @export
#'

multiomics_network <- function(multiassay,
                                list,
                                correlation_threshold = 0.5) {
  features_interest <- c(list[[1]], list[[2]])
  pk <- c(length(list[[1]]), length(list[[2]]))

  multimodal_object <- multiassay@metadata$multimodal_object$omics


  matrix1 <- t(multimodal_object[[1]])
  matrix1 <- matrix1[, list[[1]]]


  matrix2 <- t(multimodal_object[[2]])
  matrix2 <- matrix2[, list[[2]]]


  matrix <- scale(cbind(matrix1, matrix2))
  colnames(matrix) <- features_interest

  colnames(matrix)[1:pk[1]] <- paste0(colnames(matrix)[1:pk[1]], "_rna")
  colnames(matrix)[(pk[1] + 1):(pk[1] + pk[2])] <- paste0(
    colnames(matrix)[(pk[1] + 1):(pk[1] + pk[2])], "_protein")

  rho <- stats::cor(matrix)
  thr_cor <- correlation_threshold
  rho <- ifelse(abs(rho) >= thr_cor, yes = rho, no = 0)

  rho[rho < correlation_threshold] <- 0
  diag(rho) <- 0
  mygraph <- igraph::graph.adjacency(rho, weighted = TRUE, mode = "lower")


  a <- apply(rho, 1, function(x) {
    .color.gradient(x)
  })
  rownames(a) <- colnames(a)


  mynode_colours <- c(rep("#B39DDB", pk[1]), rep("#00796B", pk[2]))
  mynode_labels <- colnames(matrix)

  igraph::V(mygraph)$label <- mynode_labels
  igraph::V(mygraph)$color <- mynode_colours
  igraph::V(mygraph)$label.family <- "sans"
  igraph::V(mygraph)$label.color <- "grey20"
  igraph::E(mygraph)$weight
  igraph::V(mygraph)$label.cex <- 0.5
  set.seed(1)

  list <- list(
    graph = mygraph,
    matrix = matrix,
    hubs = hub_score(mygraph)$vector
  )
  return(list)
}

.color.gradient <- function(x,
                            colors = c("blue", "white", "red"),
                            colsteps = 100) {
  return(colorRampPalette(colors)(colsteps)[
    findInterval(x, seq(-1, 1, length.out = colsteps))])
}

#' @import igraph
#'
#' @keywords internal
.GetGraph <- function(calib_object = NULL, adjacency = NULL,
                      node_label = NULL, node_color = NULL, node_shape = NULL,
                      weighted = NULL, satellites = FALSE) {
  # either out or adjacency have to be provided

  if (is.null(adjacency)) {
    if (is.null(calib_object)) {
      stop("Either 'calib_object' or 'adjacency' needs to be provided.")
    }
    adjacency <- CalibratedAdjacency(calib_object)
  }

  if (is.null(node_color)) {
    node_color <- rep("skyblue", ncol(adjacency))
  }

  if (is.null(node_shape)) {
    node_shape <- rep("circle", ncol(adjacency))
  }

  if (is.null(node_label)) {
    node_label <- colnames(adjacency)
  }

  names(node_color) <- colnames(adjacency)
  names(node_label) <- colnames(adjacency)
  names(node_shape) <- colnames(adjacency)

  mygraph <- igraph::graph_from_adjacency_matrix(adjacency,
                                                 mode = "undirected",
                                                 weighted = weighted)
  V(mygraph)$label <- node_label[V(mygraph)$name]
  V(mygraph)$color <- node_color[V(mygraph)$name]
  V(mygraph)$shape <- node_shape[V(mygraph)$name]
  V(mygraph)$frame.color <- V(mygraph)$color
  V(mygraph)$label.family <- "sans"
  E(mygraph)$color <- "grey60"
  V(mygraph)$label.color <- "grey20"
  E(mygraph)$width <- 0.5

  return(mygraph)
}

#' Get interactive network from igraph object

#'
#' @param igraph Multi-omics network
#' @param communities Logical as whether to show communities on graph
#' @param cluster If commmunities = TRUE, provide a community object generated
#' by  `communities_network`function
#'
#' @return plots `visNetwork` graph
#'
#' @family Plotting
#'
#' @importFrom visNetwork toVisNetworkData visNetwork visIgraphLayout visNodes
#' visEdges visLayout
#'
#' @export
#'

interactive_network <- function(igraph,
                                 communities = FALSE,
                                 cluster) {
  data1 <- visNetwork::toVisNetworkData(igraph)
  data1$nodes$font.color <- "black"
  nodes1 <- data1$nodes
  edges1 <- data1$edges
  nodes1$size <- (hub_score(igraph)$vector * 30) + 1

  # Create group column
  if (communities == TRUE) {
    cluster <- communities$community_object
    cluster_df <- data.frame(as.list(membership(cluster)))
    cluster_df <- as.data.frame(t(cluster_df))
    cluster_df$label <- rownames(cluster_df)


    nodes1 <- merge(x = nodes1, y = cluster_df, by = "label", all.x = TRUE)
    colnames(nodes1)[8] <- "group"
  }

  visNetwork::visNetwork(nodes1,
    edges1,
    width = "100%", height = 800
  ) %>%
    visNetwork::visIgraphLayout(layout = "layout.fruchterman.reingold") %>%
    visNetwork::visNodes(
      color = list(
        background = "#0085AF",
        border = "#013848",
        highlight = "#FF8000",
        labelHighlightBold = TRUE
      ),
      scaling = list(
        max = 1,
        min = 1,
        label = list(
          enabled = FALSE,
          max = 1,
          min = 1
        )
      ),
      shadow = list(enabled = TRUE, size = 10)
    ) %>%
    visNetwork::visEdges(
      shadow = FALSE,
      color = list(color = "grey", highlight = "#C62F4B")
    ) %>%
    visNetwork::visLayout(randomSeed = 11)
}


#' Detects communities in multi-omics network
#'
#' @param igraph Multi-omics network
#' @param community_detection Available methods include `edge_betweeness`,
#' `leading_eigen`,`walktrap`,`fastgreedy`,`louvain` all available from the
#' `igraph` package.
#'
#' @return List object including `community_object` and `communities`
#'
#' @family Plotting
#'
#' @import igraph
#'
#' @export
#'

communities_network <- function(igraph,
                                 community_detection = "louvain") {
  if (community_detection == "edge_betweeness") {
    lc1 <- igraph::cluster_edge_betweenness(igraph, weights = NULL)
  }
  if (community_detection == "leading_eigen") {
    lc1 <- igraph::cluster_leading_eigen(igraph, weights = NULL)
  }

  if (community_detection == "walktrap") {
    lc1 <- igraph::cluster_walktrap(igraph, weights = NULL)
  }

  if (community_detection == "fastgreedy") {
    lc1 <- igraph::cluster_fast_greedy(igraph, weights = NULL)
  }
  if (community_detection == "louvain") {
    lc1 <- igraph::cluster_louvain(igraph, weights = NULL)
  }
  communities <- igraph::communities(lc1)
  names <- attributes(communities)$dimnames[[1]]
  attributes(communities) <- NULL
  names(communities) <- names

  layout <- layout.fruchterman.reingold(igraph)
  plot(lc1, igraph,
    layout = layout,
    vertex.label = NA, vertex.size = 5, edge.arrow.size = .2
  )

  return(list(
    community_object = lc1,
    communities = communities
  ))
}


#' Creates a multi-omics network based on clustered subgroups following
#' multi-omics clustering
#'
#' @param multiassay Multiassay experiment object generated by Omix
#' @param integration multi-omics clustering integration method.
#' Default `iCluster`
#' @param cluster Cluster of interest
#' @param list Named list of processed omic slots and features of interest
#' @param correlation_threshold Absolute correlation threshold to draw edges
#' in the network
#'
#' @return `Igraph` object
#'
#' @family Plotting
#'
#' @import igraph
#' @export
#'

multiomics_network_cluster <- function(multiassay,
                                        integration = "iCluster",
                                        cluster = 1,
                                        list,
                                        correlation_threshold = 0.5) {
  features_interest <- c(list[[1]], list[[2]])
  multimodal_object <- multiassay@metadata$multimodal_object$omics

  clusters <- multiassay@metadata$integration[[
    paste(integration)]]$clust.res$clust
  keep <- clusters == cluster

  matrix1 <- t(multimodal_object[[1]])
  matrix1 <- matrix1[keep, ]
  matrix1 <- matrix1[, colnames(matrix1) %in% list[[1]]]

  matrix2 <- t(multimodal_object[[2]])
  matrix2 <- matrix2[keep, ]
  matrix2 <- matrix2[, colnames(matrix2) %in% list[[2]]]

  matrix <- cbind(matrix1, matrix2)

  rho <- cor(matrix)
  thr_cor <- correlation_threshold
  rho <- ifelse(abs(rho) >= thr_cor, yes = rho, no = 0)
  A <- ifelse(rho != 0, yes = 1, no = 0)
  diag(A) <- 0


  a <- apply(rho, 1, function(x) {
    .color.gradient(x)
  })
  rownames(a) <- colnames(a)

  pk <- c(length(list[[1]]), length(list[[2]]))
  mynode_colours <- c(rep("#B39DDB", pk[1]), rep("#00796B", pk[2]))
  mynode_labels <- sub("*\\.[0-9]", "", features_interest)

  mygraph <- .GetGraph(adjacency = A,
                       node_color = mynode_colours,
                       node_label = mynode_labels)

  data <- as_edgelist(mygraph)
  V1 <- data[, 1]
  V2 <- data[, 2]
  b <- numeric()

  for (i in 1:length(V1)) {
    b[i] <- a[which(rownames(a) == V1[i]), which(colnames(a) == V2[i])]
  }

  V(mygraph)$name <- mynode_labels
  E(mygraph)$color <- b
  E(mygraph)$width <- 3
  set.seed(1)

  return(mygraph)
}

.color.gradient <- function(x,
                            colors = c("blue", "white", "red"),
                            colsteps = 100) {
  return(colorRampPalette(colors)(colsteps)[
    findInterval(x, seq(-1, 1, length.out = colsteps))])
}

#' Creates a subnetwork graph based on detected communities
#'
#' @param igraph Multi-omics network
#' @param community_object Community object generated by
#' `communities_network`function
#' @param community Community of interest
#'
#' @return A list including `graph` and `hubs`
#'
#' @family Plotting
#'
#' @import igraph
#' @export
#'

community_graph <- function(igraph,
                             community_object,
                             community = 1) {
  keep <- which(community_object$membership == community)

  ## Which nodes should be kept?
  Keep <- V(igraph)[keep]
  igraph_sub <- igraph::induced_subgraph(igraph, Keep,
                                         impl = "create_from_scratch")
  E(igraph_sub)$width <- 0.5

  res <- list(
    graph = igraph_sub,
    hubs = hub_score(igraph_sub)$vector
  )

  return(res)
}


#' Plot optimal number of clusters from `getClustNum()`
#'
#' @param optk1 Cluster Prediction Index
#' @param optk2 Gap statistics
#' @param try.N.clust A integer vector to indicate possible choices of number of clusters.
#'
#' @return plot
#' @export
#' @family Plotting
#' @importFrom ggplot2 alpha

plot_optimal_cluster <- function(optk1,
                                 optk2,
                                 try.N.clust) {
  par(bty = "o", mgp = c(1.9, .33, 0), mar = c(3.1, 3.1, 2.1, 3.1) + .1, las = 1, tcl = -.25)
  plot(NULL, NULL,
       xlim = c(min(try.N.clust), max(try.N.clust)),
       ylim = c(0, 1),
       xlab = "Number of Multi-Omics Clusters", ylab = ""
  )
  rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col = "#EAE9E9", border = FALSE)
  grid(col = "white", lty = 1, lwd = 1.5)
  points(try.N.clust, apply(optk1, 1, mean), pch = 19, col = ggplot2::alpha("#224A8D"), cex = 1.5)
  lines(try.N.clust, apply(optk1, 1, mean), col = "#224A8D", lwd = 2, lty = 4)
  mtext("Cluster Prediction Index", side = 2, line = 2, cex = 1.5, col = "#224A8D", las = 3)
  
  par(new = TRUE, xpd = FALSE)
  plot(NULL, NULL,
       xlim = c(min(try.N.clust), max(try.N.clust)),
       ylim = c(0, 1),
       xlab = "", ylab = "", xaxt = "n", yaxt = "n"
  )
  points(try.N.clust, optk2$gap, pch = 19, col = ggplot2::alpha("#E51718", 0.8), cex = 1.5)
  lines(try.N.clust, optk2$gap, col = "#E51718", lwd = 2, lty = 4)
  axis(side = 4, at = seq(0, 1, 0.2), labels = c("0.0", "0.2", "0.4", "0.6", "0.8", "1.0"))
  mtext("Gap-statistics", side = 4, line = 2, las = 3, cex = 1.5, col = "#E51718")
}

