################################################################################
#' Process bulk proteomics data
#'
#' @param multiassay  Multiassay experiment object generated by Omix
#' `generate_multiassay`function
#' @param filter Logical wether to perform protein filtering
#' @param min_sample Percentage of samples that must non missing protein
#' value, or the protein is filtered out
#'  protein value, or else the protein is excluded
#' @param dependent Dependent variable for groups.
#' If no specific dependent variable exist, set parameter as NULL
#' @param levels Character vector with reference group as first element.
#' Set parameter as NULL if dependent is NULL.
#' @param imputation Possible values are `distribution`, `minimum_value`,`zero`
#' default to `minimum_value`.
#' @param remove_feature_outliers Logical whether to remove feature outliers
#' @param batch_correction Logical whether to perform  technical batch
#'  correction
#' @param batch Technical batch
#' @param correction_method Correction methods available to counteract batch
#' effects. Possible values are `Combat` or `median_centering`
#' @param remove_sample_outliers Logical whether to remove sample outliers
#' @param denoise Logical whether to denoise biological covariates
#' @param covariates Covariates used in linear mixed model for denoising
#'
#' @return
#' @export
#'
#' @examples
process_protein <- function(multiassay,
                            # STEP 1 - FILTERING
                            filter = TRUE,
                            min_sample = 0.6,
                            dependent = "diagnosis",
                            levels = c("Control", "Mid", "Late"),
                            # IMPUTATION
                            imputation = "minimum_value",
                            # FEATURE OUTLIERS
                            remove_feature_outliers = TRUE,
                            # TECHNICAL BATCH CORRECTION
                            batch_correction = TRUE,
                            batch = "Batch",
                            correction_method = c("Combat", "Median_centering"),
                            # SAMPLE OUTLIERS
                            remove_sample_outliers = TRUE,
                            # DENOISING BIOLOGICAL COVARIATES
                            denoise = FALSE,
                            covariates = c("msex", "pmi", "apoe_genotype")) {
  "%!in%" <- function(x, y) !("%in%"(x, y))

  protein_raw <- MultiAssayExperiment::getWithColData(
    multiassay,
    "protein_raw"
  )
  colData <- data.frame(SummarizedExperiment::colData(protein_raw))

  if (!is.null(levels)) {
    colData[[dependent]] <- factor(colData[[dependent]], levels = levels)
  }

  cli::cli_alert_success("SCALING NORMALIZATION")
  matrix <- assays(protein_raw)[[1]]
  matrix <- log2(matrix)

  if (filter == TRUE) {
    cli::cli_alert_success("FILTERING")

    dim1 <- dim(matrix)[1]
    args2 <- list(
      matrix = matrix,
      min_sample = min_sample,
      groups = colData[[dependent]]
    )
    matrix <- do.call(filter_protein, args2)
    dim2 <- dim(matrix)[1]
    cli::cli_alert_success(paste(dim1 - dim2, "/", dim1, "proteins filtered"))
    cli::cli_alert_success(paste(dim2, "proteins kept for analysis"))
  }

  cli::cli_alert_success("IMPUTATION")
  if (imputation == "distribution") {
    cli::cli_alert_success(
    "Imputation of remaining missing values based on distribution")
    matrix <- .impute_distribution(matrix)
  }
  if (imputation == "minimum_value") {
    cli::cli_alert_success("Imputation of remaining missing values based on 50% of
                minimum level of abundance for each protein")
    matrix <- .impute_minimum_value(matrix)
  }

  if (imputation == "zero") {
    cli::cli_alert_success("Imputation of remaining missing values to zero")
    matrix <- matrix %>% dplyr::mutate_if(
      is.numeric,
      function(x) {
        ifelse(is.na(x),
          0, x
        )
      }
    )
  }


  if (batch_correction == TRUE) {
    cli::cli_alert_success("BATCH CORRECTION")
    batch_map <- data.frame(SummarizedExperiment::colData(protein_raw))
    batch_map$FullRunName <- rownames(batch_map)

    matrix <- batch_correction_protein(
      matrix = matrix,
      batch_map = batch_map,
      batch = batch,
      correction_method = correction_method
    )
  }


  if (denoise == TRUE) {
    cli::cli_alert_success("DENOISING BIOLOGICAL COVARIATES")
    cli::cli_alert_success(paste("Using Limma on", covariates,
                                 "as biological confounders"))

    covariates_data <- MultiAssayExperiment::colData(protein_raw)[,c(covariates)]
    covariates_data <- data.frame(covariates_data)

    matrix <- limma::removeBatchEffect(
      matrix,
      covariates = covariates_data,
      design = model.matrix(~ colData[[dependent]],
        data = colData
      )
    )
    matrix <- as.data.frame(matrix)
  }

  if (remove_feature_outliers == TRUE) {
    cli::cli_alert_success("REMOVING FEATURE OUTLIERS")
    cli::cli_h1("Remove proteins with average protein abundance
                across samples in bottom and upper 5 percentile")
    dim3 <- dim(matrix)[1]
    q <- quantile(matrix, probs = c(0.05), na.rm = TRUE)
    q2 <- quantile(matrix, probs = c(0.95), na.rm = TRUE)

    idx <- ((rowSums(matrix, 2) / ncol(matrix) > q) &
      (rowSums(matrix, 2) / ncol(matrix) < q2))
    matrix <- matrix[idx, ]
    dim4 <- dim(matrix)[1]
    cli::cli_alert_success(paste(dim3 - dim4, "feature outliers out of",
                                 dim3, "features detected and dropped"))
  }


  if (remove_sample_outliers == TRUE) {
    cli::cli_alert_success("REMOVING SAMPLE OUTLIERS")
    dim5 <- dim(matrix)[2]
    pca <- prcomp(t(matrix), scale. = TRUE, rank. = 1)
    U <- pca$x
    outliers <- rownames(apply(U, 2, function(x) {
      which(abs(x - mean(x))
      >= (3 * sd(x)))
    }))
    matrix <- matrix[, colnames(matrix) %!in% outliers]
    dim6 <- dim(matrix)[2]
    cli::cli_alert_success(paste(dim6, "sample outliers out of",
                                 dim5, " samples detected and dropped"))

    metadata(multiassay)$OutliersFlags$protein <- outliers
  }


  #####
  map <- MultiAssayExperiment::sampleMap(multiassay)
  map_df <- data.frame(map@listData)
  map_df <- map_df[which(map_df$assay == "protein_raw"), ]
  map_df <- map_df[match(colnames(matrix),
                   map_df$colname), ][c("primary", "colname")]
  map_df$assay <- "protein_processed"

  matrix <- as.data.frame(matrix)
  multiassay <- c(multiassay,
    protein_processed = matrix,
    sampleMap = map_df
  )

  metadata(multiassay)$parameters_processing_protein <- list(
    filter = filter,
    min_sample = min_sample,
    dependent = dependent,
    levels = levels,
    imputation = imputation,
    remove_feature_outliers = remove_feature_outliers,
    batch_correction = batch_correction,
    batch = batch,
    correction_method = correction_method,
    remove_sample_outliers = remove_sample_outliers,
    denoise = denoise,
    covariates = covariates
  )
  return(multiassay)

  cli::cli_alert_success("Proteomics data processed!")
  cli::cli_alert_success("Processing parameters saved in metadata")
}



processed_rna <- function(multiassay,
                          custom_processed_df) {
  matrix <- as.data.frame(custom_processed_df)
  map <- MultiAssayExperiment::sampleMap(multiassay)
  map_df <- data.frame(map@listData)
  map_df <- map_df[which(map_df$assay == "protein_raw"), ]
  map_df <- map_df[match(
    colnames(matrix),
    map_df$colname
  ), ][c("primary", "colname")]
  map_df$assay <- "protein_processed"

  rm.protein_processed <- !grepl("protein_processed",
                                  names(experiments(multiassay)))
  multiassay <- multiassay[, , rm.protein_processed]
  multiassay <- c(multiassay,
    protein_processed = matrix,
    sampleMap = map_df
  )

  metadata(multiassay)$parameters_processing_protein$custom_processed_df <- TRUE

  cli::cli_alert_success("Custom processed proteomics added!")
}
