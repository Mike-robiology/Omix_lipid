################################################################################
#' Process bulk proteomics data
#'
#' @param multiassay  Multiassay experiment object generated by Omix
#' `generate_multiassay`function
#' @param filter Logical whether to perform protein filtering
#' @param min_sample Percentage of samples that must non missing protein
#' value, or the protein is filtered out
#'  protein value, or else the protein is excluded
#' @param dependent Dependent variable for groups.
#' If no specific dependent variable exist, set parameter as NULL
#' @param levels Character vector with reference group as first element.
#' Set parameter as NULL if dependent is NULL.
#' @param imputation Possible values are `distribution`, `minimum_value`,`zero`
#' default to `minimum_value`.
#' @param remove_feature_outliers Logical whether to remove feature outliers
#' @param batch_correction Logical whether to perform  technical batch
#'  correction
#' @param batch Technical batch
#' @param correction_method Correction methods available to counteract batch
#' effects. Possible values are `Combat` or `median_centering`
#' @param remove_sample_outliers Logical whether to remove sample outliers
#' @param denoise Logical whether to denoise biological covariates
#' @param covariates Covariates used in linear mixed model for denoising
#
#' @return a MultiAssayExperiment object with `protein_processed` slot
#'
#' @family Pre-processing
#'
#' @importFrom MultiAssayExperiment MultiAssayExperiment listToMap colData
#' getWithColData sampleMap metadata experiments
#' @importFrom SummarizedExperiment SummarizedExperiment assay rowData
#' @export
#'

process_protein <- function(multiassay,
                            # STEP 1 - FILTERING
                            filter = TRUE,
                            min_sample = 0.5,
                            dependent = "diagnosis",
                            levels = c("Control", "AD"),
                            # IMPUTATION
                            imputation = "minimum_value",
                            # FEATURE OUTLIERS
                            remove_feature_outliers = TRUE,
                            # TECHNICAL BATCH CORRECTION
                            batch_correction = TRUE,
                            batch = "batch",
                            correction_method = c("Combat", "Median_centering"),
                            # SAMPLE OUTLIERS
                            remove_sample_outliers = TRUE,
                            # DENOISING BIOLOGICAL COVARIATES
                            denoise = FALSE,
                            covariates = c("sex", "age")) {


  "%!in%" <- function(x, y) !("%in%"(x, y))

  protein_raw <- MultiAssayExperiment::getWithColData(
    multiassay,
    "protein_raw"
  )
  colData <- data.frame(SummarizedExperiment::colData(protein_raw))

  if (!is.null(levels)) {
    colData[[dependent]] <- factor(colData[[dependent]], levels = levels)
  }

  cli::cli_alert_success("SCALING NORMALIZATION")
  matrix <- SummarizedExperiment::assays(protein_raw)[[1]]
  matrix <- log2(matrix)

  if (filter == TRUE) {
    cli::cli_alert_success("FILTERING")

    dim1 <- dim(matrix)[1]
    args2 <- list(
      matrix = matrix,
      min_sample = min_sample,
      groups = colData[[dependent]]
    )

    matrix <- do.call(filter_protein, args2)
    dim2 <- dim(matrix)[1]
    cli::cli_alert_success(paste(dim1 - dim2, "/", dim1, "proteins filtered"))
    cli::cli_alert_success(paste(dim2, "proteins kept for analysis"))
  }

  cli::cli_alert_success("IMPUTATION")

  if (imputation == "distribution") {
    cli::cli_alert_success(
      "Imputation of remaining missing values based on distribution"
    )
    matrix <- impute_distribution(matrix)
  }
  if (imputation == "minimum_value") {
    cli::cli_alert_success("Imputation of remaining missing values based on
    50% of minimum level of abundance for each protein")
    matrix <- impute_minimum_value(matrix)
  }

  if (imputation == "zero") {
    cli::cli_alert_success("Imputation of remaining missing values to zero")
    matrix <- matrix %>% dplyr::mutate_if(
      is.numeric,
      function(x) {
        ifelse(is.na(x),
               0, x
        )
      }
    )
  }

  matrix <- as.data.frame(matrix, col.names = colnames(matrix))


  if (batch_correction == TRUE) {
    cli::cli_alert_success("BATCH CORRECTION")
    batch_map <- data.frame(SummarizedExperiment::colData(protein_raw))
    batch_map$FullRunName <- rownames(batch_map)

    matrix <- batch_correction_protein(
      matrix = matrix,
      batch_map = batch_map,
      batch = batch,
      correction_method = correction_method
    )
  }


  if (denoise == TRUE) {
    cli::cli_alert_success("DENOISING BIOLOGICAL COVARIATES")
    cli::cli_alert_success(paste(
      "Using Limma on", covariates,
      "as biological confounders"
    ))

    covariates_data <- MultiAssayExperiment::colData(protein_raw)[, c(covariates)]
    covariates_data <- data.frame(covariates_data)
    covariates_data <- covariates_data %>%
      mutate(across(where(is.character), as.factor))
    covariates_data <- covariates_data %>%
      mutate(across(where(is.factor), as.numeric))

    for (i in colnames(covariates_data)){

      if (all(!is.na(covariates_data[, i])) == FALSE) {
        stop(cli::cli_alert_danger(
          paste(i, "Contains missing data,
                please impute or remove this covariate",
                sep = " "
          )))
      }
    }

    matrix <- limma::removeBatchEffect(
      matrix,
      batch = NULL,
      covariates = covariates_data,
      design = model.matrix(~ colData[[dependent]]),
      data = colData
    )

    matrix <- as.data.frame(matrix)
  }

  if (remove_feature_outliers == TRUE) {
    cli::cli_alert_success("REMOVING FEATURE OUTLIERS")
    cli::cli_h1("Remove proteins with average protein abundance
                across samples in bottom and upper 5 percentile")
    dim3 <- dim(matrix)[1]
    q <- quantile(matrix, probs = c(0.05), na.rm = TRUE)
    q2 <- quantile(matrix, probs = c(0.95), na.rm = TRUE)

    idx <- ((rowSums(matrix, 2) / ncol(matrix) > q) &
              (rowSums(matrix, 2) / ncol(matrix) < q2))
    matrix <- matrix[idx, ]
    dim4 <- dim(matrix)[1]
    cli::cli_alert_success(paste(
      dim3 - dim4, "feature outliers out of",
      dim3, "features detected and dropped"
    ))
  }


  if (remove_sample_outliers == TRUE) {
    cli::cli_alert_success("REMOVING SAMPLE OUTLIERS")
    dim5 <- dim(matrix)[2]
    pca <- prcomp(t(matrix), scale. = TRUE, rank. = 1)
    U <- pca$x
    outliers <- rownames(apply(U, 2, function(x) {
      which(abs(x - mean(x))
            >= (3 * sd(x)))
    }))
    matrix <- matrix[, colnames(matrix) %!in% outliers]
    dim6 <- dim(matrix)[2]
    cli::cli_alert_success(paste(
      dim5 - dim6, "sample outliers out of",
      dim5, " samples detected and dropped"
    ))

    MultiAssayExperiment::metadata(multiassay)$OutliersFlags$protein <-
      outliers
  }


  #####
  map <- MultiAssayExperiment::sampleMap(multiassay)
  map_df <- data.frame(map@listData)
  map_df <- map_df[which(map_df$assay == "protein_raw"), ]
  map_df <- map_df[match(
    colnames(matrix),
    map_df$colname
  ), ][c("primary", "colname")]
  map_df$assay <- "protein_processed"

  multiassay <- c(multiassay,
                  protein_processed = matrix,
                  sampleMap = map_df
  )

  MultiAssayExperiment::metadata(multiassay)$parameters_processing_protein <-
    list(
    filter = filter,
    min_sample = min_sample,
    dependent = dependent,
    levels = levels,
    imputation = imputation,
    remove_feature_outliers = remove_feature_outliers,
    batch_correction = batch_correction,
    batch = batch,
    correction_method = correction_method,
    remove_sample_outliers = remove_sample_outliers,
    denoise = denoise,
    covariates = covariates
  )
  return(multiassay)

  cli::cli_alert_success("Proteomics data processed!")
  cli::cli_alert_success("Processing parameters saved in metadata")
}



#' Adds a custom processed proteomics dataset to multiassay object
#'
#' @param multiassay Multiassay experiment object generated by Omix
#' `generate_multiassay`function
#' @param custom_processed_df processed dataframe
#'
#' @return multiassay object with custom slot
#' @export
#'
processed_proteomics <- function(multiassay,
                                 custom_processed_df) {
  matrix <- as.data.frame(custom_processed_df)
  map <- MultiAssayExperiment::sampleMap(multiassay)
  map_df <- data.frame(map@listData)
  map_df <- map_df[which(map_df$assay == "protein_raw"), ]
  map_df <- map_df[match(
    colnames(matrix),
    map_df$colname
  ), ][c("primary", "colname")]
  map_df$assay <- "protein_processed"

  rm_protein_processed <- !grepl(
    "protein_processed",
    names(MultiAssayExperiment::experiments(multiassay))
  )
  multiassay <- multiassay[, , rm_protein_processed]
  multiassay <- c(multiassay,
                  protein_processed = matrix,
                  sampleMap = map_df
  )

  MultiAssayExperiment::metadata(
    multiassay)$parameters_processing_protein$custom_processed_df <- TRUE

  cli::cli_alert_success("Custom processed proteomics added!")
}
