#' Downstream analysis for integrated multi-omics data
#'
#' @param multiassay Multiassay experiment object generated by Omix
#' @param integration_model Possible unsupervised integration methods are `MOFA`,
#' @param dependent Dependent variable for groups.
#' @param correlation_threshold Absolute correlation threshold to draw edges
#' in the network
#' @param disease_id OpenTargets disease id. Default to "MONDO_0004975"
#' (Alzheimer's Disease) Different disease ontologies can be found on
#' https://www.ebi.ac.uk/ols/ontologies
#' @param sense_check_variable sense check
#' @param covariates cov
#' @param time tim
#' @param weights_threshold weights threshold
#' @param community_detection community detection method
#' @param pseudotime_analysis TRUE/ FALSE
#'
#' @return List object of integrated results
#'
#' @family Multi-omic integration downstream analysis
#'
#' @importFrom purrr possibly
#' @importFrom clusterProfiler enrichGO compareCluster
#' @importFrom enrichplot pairwise_termsim
#' @importFrom org.Hs.eg.db org.Hs.eg.db
#' @importFrom MOFA2 get_weights correlate_factors_with_covariates plot_variance_explained
#' @export

integrative_results_unsupervised <- function(multiassay,
                                             integration_model = "MOFA",
                                             dependent = "diagnosis",
                                             sense_check_variable = "PHF1",
                                             covariates = c("PHF1", "amyloid", "AT8"),
                                             weights_threshold = 0.2,
                                             correlation_threshold = 0.4,
                                             community_detection = "leading_eigen",
                                             pseudotime_analysis = TRUE,
                                             time = NA,
                                             disease_id = "MONDO_0004975") {
  cli::cli_h2("Generating integrative muti-omics results ")

  integrated_object <- multiassay@metadata$integration[[integration_model]]
  variance <- data.frame(MOFA2::get_variance_explained(integrated_object)$r2_per_factor$group1)
  variance$mRNA=signif(  variance$mRNA,3)
  variance$proteins=signif(  variance$proteins,3)
  ## Sign
  cli::cli_text("Retrieving signatures...")
  factor <- MOFA_get_relevant_factor(integrated_object, covariate = sense_check_variable)
  sign <- MOFA_sign_relevant_factor(integrated_object, covariate = sense_check_variable, factor)

  ## Multi-omics network
  args <- list(
    integrated_object,
    factor = MOFA_get_relevant_factor(integrated_object, covariate = sense_check_variable),
    threshold = weights_threshold,
    sense_check_variable = sense_check_variable
  )

  cli::cli_text("Retrieving weights...")
  weights <- do.call(extract_weigths, args)

  cli::cli_text("Generating multi-omics network...")
  weights_pos_neg <- list()
  weights_pos_neg$positive <- multiomics_network(
    multiassay = multiassay,
    list = weights$weights$ranked_weights_positive,
    correlation_threshold = correlation_threshold,
    filter_string_50= TRUE
  )

  weights_pos_neg$negative <- multiomics_network(
    multiassay = multiassay,
    list = weights$weights$ranked_weights_negative,
    correlation_threshold = correlation_threshold,
    filter_string_50= TRUE
  )


  ## Network communities detection
  cli::cli_text("Detecting network communities...")
  communities_pos_neg <- list()
  communities_pos_neg$positive <- communities_network(
    igraph = weights_pos_neg$positive$graph,
    community_detection = community_detection
  )
  communities_pos_neg$negative <- communities_network(
    igraph = weights_pos_neg$negative$graph,
    community_detection = community_detection
  )



  ## Cell type enrichment
  cli::cli_text("Cell type enrichment of communities...")

  cell_type <- list()
  cell_type$positive <- cell_type_enrichment(
    multiassay = multiassay,
    communities = lapply(communities_pos_neg$positive$communities, function(x) {
      sub("\\_.*", "", x)
    })
  )
  cell_type$negative <- cell_type_enrichment(
    multiassay = multiassay,
    communities = lapply(communities_pos_neg$negative$communities, function(x) {
      sub("\\_.*", "", x)
    })
  )


  ## Functional enrichment
  cli::cli_text("Functional enrichment of communities...")

  communities_positive <- lapply(communities_pos_neg$positive$communities, function(x) {
    sub("\\_.*", "", x)
  })
  communities_negative <- lapply(communities_pos_neg$negative$communities, function(x) {
    sub("\\_.*", "", x)
  })

  enrichment <- list()
  enrichment$positive <- lapply(communities_positive, pathway_analysis_enrichr)
  enrichment$negative <- lapply(communities_negative, pathway_analysis_enrichr)


  ## Transcription Factor enrichment
  cli::cli_text("Transcription factor - target gene enrichment in communities...")

  TF <- list()
  TF$positive <- Transcription_Factor_enrichment(
    communities = communities_pos_neg$positive$communities,
    weights = weights,
    TF_gmt = TF_fp,
    threshold = weights_threshold,
    direction = "positive"
  )

  TF$negative <- Transcription_Factor_enrichment(
    communities = communities_pos_neg$negative$communities,
    weights = weights,
    TF_gmt = TF_fp,
    threshold = weights_threshold,
    direction = "negative"
  )

  ## Multi-omics modules (eigenvalue)
  cli::cli_text("Computing module eigen expression for communities...")

  modules <- list()

  modules$positive <- multiomics_modules(
    multiassay = multiassay,
    metadata = MOFA2::samples_metadata(integrated_object),
    covariates = covariates,
    communities = communities_pos_neg$positive$communities,
    filter_string_50=TRUE
  )

  modules$negative <- multiomics_modules(
    multiassay = multiassay,
    metadata = MOFA2::samples_metadata(integrated_object),
    covariates = covariates,
    communities = communities_pos_neg$negative$communities,
    filter_string_50=TRUE
  )

  boxplots <- list()
  for (i in colnames(modules$positive$modules_eigen_value)) {
    boxplots$positive[[i]] <- ggpubr::ggboxplot(modules$positive$metadata_modules,
      x = dependent,
      y = paste(i),
      add = "jitter",
      color = dependent
    ) +
      xlab(paste(dependent)) +
      ylab(paste("Eigen value in", i)) +
      theme_classic() +
      ggsignif::geom_signif() +
      scale_color_manual(values = c("#2E9FDF", "#E7B800"))
  }


  for (i in colnames(modules$negative$modules_eigen_value)) {
    boxplots$negative[[i]] <- ggpubr::ggboxplot(modules$negative$metadata_modules,
      x = dependent,
      y = paste(i),
      add = "jitter",
      color = dependent
    ) +
      xlab(paste(dependent)) +
      ylab(paste("Eigen value in", i)) +
      theme_classic() +
      ggsignif::geom_signif() +
      scale_color_manual(values = c("#2E9FDF", "#E7B800"))
  }




  ## Correlation heatmap
  correlation_heatmap <- correlation_heatmap(integrated_object,
    covariates = covariates
  )


  ## Pseudo-time analysis
  if (pseudotime_analysis == TRUE) {
    cli::cli_text("Pseudotime analysis...")

    time_factor <- MOFA_get_pseudotime_factor(integrated_object, covariate = time)
    second_factor <- MOFA_get_relevant_factor(integrated_object, covariate = sense_check_variable)

    clusters <- MOFA2::cluster_samples(integrated_object,
      k = 3,
      factors = c(time_factor, second_factor)
    )
    pseudotime <- pseudotime_inference(integrated_object,
      clusters,
      time_factor = time_factor,
      second_factor = second_factor,
      start.clus = 2,
      end.clus = 1,
      lineage = "Lineage1"
    )

    integrated_object <- pseudotime$model
    module_trajectory <- list()
    module_trajectory$positive <- plot_module_trajectory(
      modules = modules$positive,
      covariates = covariates,
      plot_modules = names(modules$positive$modules_eigen_value)
    )

    module_trajectory$negative <- plot_module_trajectory(
      modules = modules$negative,
      covariates = covariates,
      plot_modules = names(modules$negative$modules_eigen_value)
    )
  }



  ### Open targets
  cli::cli_text("Testing association of targets with disease of interest via the Open Targets API...")


  OpenTargets_results <- list()


  OpenTargets_results$positive$rna$df <- OpenTarget_dataframe(
    disease_id = disease_id,
    size = 1000,
    genes = weights$weights$ranked_weights_positive$rna
  )

  OpenTargets_results$positive$rna$plot <- plot_OpenTarget(
    disease_id = disease_id,
    size = 1000,
    genes = weights$weights$ranked_weights_positive$rna
  )

  OpenTargets_results$positive$protein$df <- OpenTarget_dataframe(
    disease_id = disease_id,
    size = 1000,
    genes = weights$weights$ranked_weights_positive$protein
  )

  OpenTargets_results$positive$protein$plot <- plot_OpenTarget(
    disease_id = disease_id,
    size = 1000,
    genes = weights$weights$ranked_weights_positive$protein
  )

  OpenTargets_results$negative$rna$df <- OpenTarget_dataframe(
    disease_id = disease_id,
    size = 1000,
    genes = weights$weights$ranked_weights_negative$rna
  )

  OpenTargets_results$negative$rna$plot <- plot_OpenTarget(
    disease_id = disease_id,
    size = 1000,
    genes = weights$weights$ranked_weights_negative$rna
  )

  OpenTargets_results$negative$protein$df <- OpenTarget_dataframe(
    disease_id = disease_id,
    size = 1000,
    genes = weights$weights$ranked_weights_negative$protein
  )

  OpenTargets_results$negative$protein$plot <- plot_OpenTarget(
    disease_id = disease_id,
    size = 1000,
    genes = weights$weights$ranked_weights_negative$protein
  )


  ## Track param
  parameters <- list(
    integration_model = integration_model,
    dependent = dependent,
    sense_check_variable = sense_check_variable,
    covariates = covariates,
    time = time,
    weights_threshold = weights_threshold,
    correlation_threshold = correlation_threshold,
    community_detection = community_detection,
    pseudotime_analysis = pseudotime_analysis,
    disease_id = disease_id
  )

  #### RESULTS OBJECT
  integrative_results <- list(
    detected_factor = factor,
    direction_analysis = sign,
    variance=  variance,
    correlation_heatmap=  correlation_heatmap,
    weights = weights,
    multiomic_networks=weights_pos_neg,
    communities = communities_pos_neg,
    cell_type = cell_type,
    functional_enrichment = enrichment,
    TF = TF,
    modules = modules,
    OpenTargets = OpenTargets_results,
    analysis_parameters = parameters
  )

  if (pseudotime_analysis == TRUE) {
    integrative_results <- list(
      detected_factor = factor,
      direction_analysis = sign,
      variance=  variance,
      correlation_heatmap=  correlation_heatmap,
      weights = weights,
      multiomic_networks=weights_pos_neg,
      communities = communities_pos_neg,
      cell_type = cell_type,
      functional_enrichment = enrichment,
      TF = TF,
      pseudotime_analysis = pseudotime,
      modules = modules,
      module_trajectory = module_trajectory,
      OpenTargets = OpenTargets_results,
      analysis_parameters = parameters
    )
  }

  MultiAssayExperiment::metadata(multiassay)$integrative_results[[integration_model]] <- integrative_results
  return(multiassay)
}


#' Selects the top factor that is most strongly associated with outcomes of interest and that has the most balanced explained variation across omic layers

#'
#' @param MOFAobject MOFA model
#' @param covariate Covariate of interest
#'
#' @return String of relevant factor
#' @importFrom MOFA2 correlate_factors_with_covariates
#' @keywords internal

MOFA_get_relevant_factor <- function(MOFAobject, covariate) {
  corr <- MOFA2::correlate_factors_with_covariates(MOFAobject,
    covariates = covariate,
    plot = "r",
    return_data = TRUE
  )
  variance <- data.frame(MOFA2::get_variance_explained(integrated_object)$r2_per_factor$group1)
  variance$rule <- ifelse(abs(variance$mRNA - variance$proteins) >= 2, "Unbalanced", "Balanced")
  merge <- cbind(corr, variance)
  merge$col1 <- merge[, 1]
  relevant_factor <- merge %>%
    filter(rule == "Balanced") %>%
    arrange(desc(abs(col1))) %>%
    slice(1)
  relevant_factor <- rownames(relevant_factor)
  relevant_factor_number <- as.numeric(substr(relevant_factor, 7, 9))

  return(relevant_factor_number)
}

#' Selects the top factor that is most strongly associated with outcomes of interest

#'
#' @param MOFAobject MOFA model
#' @param covariate Covariate of interest
#'
#' @return String of relevant factor
#' @importFrom MOFA2 correlate_factors_with_covariates
#' @keywords internal

MOFA_get_pseudotime_factor <- function(MOFAobject, covariate) {
  corr <- MOFA2::correlate_factors_with_covariates(MOFAobject,
    covariates = covariate,
    plot = "r",
    return_data = TRUE
  )


  relevant_factor <- rownames(corr)[which(abs(corr) == max(abs(corr)))]
  relevant_factor_number <- as.numeric(substr(relevant_factor, 7, 9))

  return(relevant_factor_number)
}

MOFA_sign_relevant_factor <- function(MOFAobject, covariate, relevant_factor) {
  corr <- MOFA2::correlate_factors_with_covariates(MOFAobject,
    covariates = covariate,
    plot = "r",
    return_data = TRUE
  )
  sign <- sign(corr[relevant_factor, ])
  return(sign)
}
