################################################################################
#' Get metadata
#'
#' @param multiassay
#' @param omic
#' @param slot
#'
#' @return

#' @importFrom MultiAssayExperiment MultiAssayExperiment listToMap colData
#'  getWithColData sampleMap
#' @export
#'
#'
#' @examples
.get_metadata <- function(multiassay,
                          omic,
                          slot = c("rna_processed", "protein_processed")) {
  data <- multiassay@ExperimentList@listData[[paste(slot)]]

  if (omic == "protein") {
    raw <- MultiAssayExperiment::getWithColData(multiassay,
      i = "protein_raw",
      mode = "replace",
      verbose = F
    )
  }
  if (omic == "rna") {
    raw <- MultiAssayExperiment::getWithColData(multiassay,
      i = "rna_raw",
      mode = "replace",
      verbose = F
    )
  }
  colData <- data.frame(SummarizedExperiment::colData(raw))
  if (omic == "protein") {
    order <- map_protein$primary[match(colnames(raw), map_protein$colname)]
  }

  if (omic == "rna") {
    order <- map_rna$primary[match(colnames(raw), map_rna$colname)]
  }

  colData <- MultiAssayExperiment::colData[order, ]

  return(colData)
}

#' Convert nomenclature
#'
#' @param id
#' @param omic
#' @param from
#' @param to
#'
#' @return
#' @export
#'
#' @examples
.get_ID_names <- function(multiassay,
                          id,
                          omic = "protein",
                          from = "uniprot_id",
                          to = "gene_name") {

  if (omic == "protein") {
    elementMetadata <- data.frame(multiassay@ExperimentList@listData[["protein_raw"]]@elementMetadata@listData)
    new_id <- elementMetadata[[paste(to)]][match(id,
              elementMetadata[[paste(from)]])]
    new_id[is.na(new_id)] <- id[is.na(new_id)]
  }
  if (omic == "rna") {
    elementMetadata <- data.frame(multiassay@ExperimentList@listData[["rna_raw"]]@elementMetadata@listData)
    new_id <- elementMetadata[[paste(to)]][match(id,
              elementMetadata[[paste(from)]])]
    new_id[is.na(new_id)] <- id[is.na(new_id)]
  }

  return(new_id)
}



#' Get background genes
#'
#' @param multiassay
#' @param of Possible values are `full`, `protein`,`rna`, respectively for
#' the background of the union between transcriptomics and proteomics, or of one
#' of the omic layers
#' default to `full`.
#'
#' @return
#' @export
#'
#' @examples
.get_background <- function(multiassay,
                            of = "full") {
  multiassay=multiassay
  if (of == "full") {
    background <- union(
      multiassay@ExperimentList@listData[["rna_raw"]]@elementMetadata@listData[["gene_name"]],
      multiassay@ExperimentList@listData[["protein_raw"]]@elementMetadata@listData[["gene_name"]]
    )
  }

  if (of == "rna") {
    background <- multiassay@ExperimentList@listData[["rna_raw"]]@elementMetadata@listData[["gene_name"]]
  }
  if (of == "protein") {
    background <- multiassay@ExperimentList@listData[["protein_raw"]]@elementMetadata@listData[["gene_name"]]
  }

  return(background)
}


#' Get nomenclature type
#'
#' @param character_vector
#'
#' @return
#' @export
#'
#' @examples
.get_ID_type <- function(character_vector) {

  test <- sub("\\;.*", "",character_vector[1])

  if (isTRUE(grepl(
    "^[A-Z0-9-]+$|^C[0-9XY]+orf[0-9]+$",
    test
  ))) {
    ID_type <- "gene_name"
  }

  if (isTRUE(grepl("ENS", test))) {
    ID_type <- "ensembl_gene_id"
  }

  if (isTRUE(!grepl("\\D", test))) {
    ID_type <- "entrez_gene_id"
  }

  if (isTRUE(grepl(
    "[OPQ][0-9][A-Z0-9]{3}[0-9]|[A-NR-Z][0-9]([A-Z][A-Z0-9]{2}[0-9]){1,2}",
    test
  ))) {
    ID_type <- "uniprot_id"
  }

  if (isTRUE(!exists("ID_type"))) {
    ID_type <- "not_identified"
    cli::cli_warn("ID type not identified!")
  }

  return(ID_type)
}


#' Extract the multimodal object
#'
#' @param multiassay Multiassay experiment object generated by Omix
#' @param slots Default to processed slots
#' @param intersect_genes Logical whether to intersect common genes between
#' omic layers
#' @param ID_type Possible values are `gene_name`, `original`,
#' Default to gene_name
#'
#' @return A list object containing the multimodal object and metadata
#' @export
#'
#' @examples
.get_multimodal_object <- function(multiassay,
                                   slots = c(
                                     "rna_processed",
                                     "protein_processed"
                                   ),
                                   intersect_genes = FALSE,
                                   ID_type = "gene_name", ...) {

  multi <- multiassay[, , c(slots[1], slots[2])]
  complete <- MultiAssayExperiment::complete.cases(multi)
  CompleteMulti <- multi[, MultiAssayExperiment::complete.cases(multi), ]

  if (intersect_genes == TRUE) {

    id1=rownames(CompleteMulti@ExperimentList@listData[[paste(slots[1])]])
    args1 <- list(
      multiassay = multiassay,
      id = id1,
      omic = "rna",
      from = "ensembl_gene_id",
      to = "gene_name"
    )

    names <- do.call('.get_ID_names', args1)
    names <- make.unique(names)
    rownames(CompleteMulti@ExperimentList@listData[[paste(slots[1])]]) <- names

    id2= rownames(CompleteMulti@ExperimentList@listData[[paste(slots[2])]])
    args2 <- list(
      multiassay = multiassay,
      id = id2,
      omic = "rna",
      from = "ensembl_gene_id",
      to = "gene_name"
    )

    names <- do.call('.get_ID_names', args2)
    names <- make.unique(names)
    rownames(CompleteMulti@ExperimentList@listData[[paste(slots[2])]]) <- names

    CompleteMulti <- MultiAssayExperiment::intersectRows(
      CompleteMulti[, , slots])
  }

  metadata <- data.frame(MultiAssayExperiment::colData(CompleteMulti))
  multimodal_omics <- lapply(CompleteMulti@ExperimentList@listData, as.matrix)
  multimodal_omics <- lapply(multimodal_omics, "colnames<-", rownames(metadata))

  if (ID_type == "gene_name") {

    args=list(character_vector=rownames(CompleteMulti@ExperimentList@listData[[paste(slots[1])]]))
    id_1 <- do.call(".get_ID_type",args)

    if (id_1 != "gene_name") {

      id3=rownames(CompleteMulti@ExperimentList@listData[[paste(slots[1])]])
      args3 <- list(
        multiassay = multiassay,
        id = id3,
        omic = "rna",
        from = "ensembl_gene_id",
        to = "gene_name"
      )

      names <- do.call('.get_ID_names', args3)
      names <- make.unique(names)
      rownames(multimodal_omics[[1]]) <- names

    }

    args=list(character_vector=rownames(CompleteMulti@ExperimentList@listData[[paste(slots[2])]]))
    id_2 <- do.call(".get_ID_type",args)

    if (id_2 != "gene_name") {

      id4=rownames(CompleteMulti@ExperimentList@listData[[paste(slots[2])]])
      args4 <- list(
        multiassay = multiassay,
        id = id4,
        omic = "protein",
        from = "uniprot_id",
        to = "gene_name"
      )

      names <- do.call('.get_ID_names', args4)
      names <- make.unique(names)
      rownames(multimodal_omics[[2]]) <- names
    }
  }


  return(list(
    multimodal_object = multimodal_omics,
    metadata = metadata
  ))
}


get_module_annotation <- function(gene_list,
                                  moduleColors) {
  library(org.Hs.eg.db)
  entrez <- AnnotationDbi::mapIds(org.Hs.eg.db, sub("\\_.*", "", gene_list),
                                  "ENTREZID", "SYMBOL")
  GOenr <- WGCNA::GOenrichmentAnalysis(moduleColors, entrez, organism = "human",
                                       nBestP = 1, ontologies = "BP")
  tab <- GOenr$bestPTerms$BP$forModule
  names <- NULL
  for (i in 1:length(tab)) {
    names[[i]] <- tab[[i]][[1]][["termName"]]
  }
  return(names)
}
