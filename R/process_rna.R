################################################################################
#' Process batch transcriptomics data
#'
#' @param multiassay Multiassay experiment object generated by Omix
#' `generate_multiassay`function
#' @param transformation transformation method to choose from. Available methods
#' are vst, rlog, and log2.
#' @param filter Logical whether to perform gene filtering
#' @param protein_coding Logical whether to filter out non protein coding genes
#' @param min_count Minimum count
#' @param min_sample Percentage of samples that have at least the `min_count`,
#' or else the gene is filtered out
#' @param dependent Dependent variable for the DeSEQ2 analysis, usually the
#' disease group variable
#' @param levels Character vector with reference group as first element.
#' Set parameter as NULL if dependent is NULL.
#' @param covariates Technical and biological covariates to use for
#' DESEQ2 analysis and denoising
#' @param batch_correction Logical whether to perform batch correction. The
#' processed matrix returned will be denoised for designated covariates and
#' technical batch.
#' @param batch Technical batch, use batch2 for another technical batch
#' @param remove_sample_outliers Logical whether to remove sample outliers
#'
#' @return a MultiAssayExperiment object with `rna_processed` slot
#'
#' @family Pre-processing
#'
#' @importFrom MultiAssayExperiment MultiAssayExperiment listToMap colData
#' @importFrom MultiAssayExperiment getWithColData sampleMap metadata
#' @importFrom SummarizedExperiment SummarizedExperiment assay rowData
#' @importFrom DESeq2 DESeqDataSetFromMatrix counts
#' @importFrom stats prcomp model.matrix
#' @importFrom magrittr set_names
#' @importFrom cli cli_alert_danger style_bold cli_alert_success
#' @importFrom limma removeBatchEffect
#' @importFrom dplyr %>%
#'
#' @export

process_rna <- function(multiassay,
                        transformation = c("vst", "rlog", "log2"),
                        protein_coding=TRUE,
                        filter=TRUE,
                        min_count = 10,
                        min_sample = 0.5,
                        dependent='diagnosis',
                        levels = NULL,
                        covariates,
                        batch_correction=TRUE,
                        batch='batch',
                        remove_sample_outliers=FALSE) {
  "%!in%" <- function(x, y) !("%in%"(x, y))
  assay_names <- names(multiassay)
  rna_assay <- grep('rna_raw', assay_names, value = TRUE)
  suppressMessages({
    rna_raw <- MultiAssayExperiment::getWithColData(
      multiassay,
      rna_assay
    )
  })

  colData <- data.frame(SummarizedExperiment::colData(rna_raw))

  design_formula <- ~1 # default formula
  if (!is.null(levels)) {
    colData[[dependent]] <- factor(colData[[dependent]], levels = levels)
  }

  if (!is.null(dependent)) { # null dependent = no modelling
    if (is.null(batch)) {
      design_formula <- as.formula(paste("~", dependent, "+", paste(covariates,
                                                                    sep = " ",
                                                                    collapse = " + "
      )))
    }
    if (!is.null(batch)) {
      design_formula <- as.formula(paste("~", dependent, "+", paste(covariates,
                                                                    sep = " ",
                                                                    collapse = " + "
      ), "+ ", batch))
    }
  }


  for (i in covariates) {
    rna_raw <- rna_raw[, !is.na(rna_raw[[paste(i)]])]
  }
  suppressMessages({
    countData <- SummarizedExperiment::assays(rna_raw)[[1]]
    colData <- colData[colnames(countData), ]
  })

  if (!all(colnames(countData) == rownames(colData))) {
    stop(cli::cli_alert_danger(
      paste("The columns in the", cli::style_bold("countData"),
        "should be same as the rows in", cli::style_bold("colData"),
        sep = " "
      )
    ))
  }

  suppressMessages({
  dds <- DESeq2::DESeqDataSetFromMatrix(
    countData = countData,
    colData = colData,
    design = design_formula
  )

  dds <- DESeq2::estimateSizeFactors(dds)
  dim1 <- as.numeric(dim(dds)[1])

  processing_outputs=list()

  })
  cli::cli_alert_success("NORMALISATION & TRANSFORMATION")
  suppressMessages({
  mean_values_feature_df=data.frame(count=rowMeans(counts(dds))) %>% tibble::rownames_to_column(var='ensembl')%>% as.data.frame()
  mean_values_feature_df$gene_id=make.unique(get_ID_names(multiassay,
                                                          id=mean_values_feature_df$ensembl,
                                                          assay_name = rna_assay,
                                                          omic = "rna",
                                                          from = "ensembl_gene_id",
                                                          to = "gene_name"))


  processing_outputs[["raw"]]=list(mean_values_feature_df= mean_values_feature_df,
                                   mean_values_sample=  colMeans(counts(dds)))
  })

  if (transformation == "log2") {
    suppressMessages({
    matrix <- data.frame(log2(DESeq2::counts(dds, normalized = TRUE) + 1))
    })
  }

  if (transformation == "vst") {
    suppressMessages({
    vsd <- DESeq2::vst(dds, blind = FALSE)
    matrix <- as.data.frame(SummarizedExperiment::assay(vsd))
    })
  }

  if (transformation == "rlog") {
    suppressMessages({
    rlog <- DESeq2::rlog(dds, blind = FALSE)
    matrix <- as.data.frame(SummarizedExperiment::assay(rlog))
    })
  }

  if (filter == TRUE) {
    cli::cli_alert_success("GENE FILTERING")
    if (protein_coding == TRUE) {
      cli::cli_alert_success("Keeping only protein coding genes")
      suppressMessages({
      protein_coding_keep <- SummarizedExperiment::rowData(
        rna_raw)$gene_biotype == "protein_coding" &
        !is.na(SummarizedExperiment::rowData(rna_raw)$gene_biotype)
      dds <- dds[protein_coding_keep, ]
      })
      cli::cli_alert_success(paste(
        dim1 - sum(protein_coding_keep),
        "/", dim1, "non protein coding genes were dropped"
      ))
      cli::cli_alert_success(paste(
        sum(protein_coding_keep),
        "protein coding genes kept for analysis"
      ))
      dim2 <- as.numeric(dim(dds)[1])

      processing_outputs[["protein_coding_filtering"]]=list(non_protein_coding=(dim1 - dim2),
                                                  percentage_protein_coding= dim2/dim1,
                                                  protein_coding_kept= dim2)
      dim1=dim2
    }
    cli::cli_alert_success(paste(
      "QC parameters selected require genes to have at least",
      (min_sample * 100), "% of samples with counts of", min_count, "or more"
    ))
    idx <- rowSums(DESeq2::counts(dds,
      normalized = TRUE) >=
      min_count) >= dim(dds)[2] * min_sample

    keep <- as.numeric(sum(idx == TRUE))
    rnas_raw=rownames(counts(dds))
    dds <- dds[idx, ]
    cli::cli_alert_success(paste(
      dim1 - keep,
      "/", dim1, "genes were dropped"
    ))
    rnas_filtered=rownames(counts(dds))

    processing_outputs[["filtering"]]=list(gene_filtered=  dim1 - keep,
                                           percentage_filtered= (dim1 - keep)/dim1,
                                           genes_kept=keep)

    mean_values_feature_df=data.frame(count=rowMeans(counts(dds))) %>% tibble::rownames_to_column(var='ensembl')%>% as.data.frame()
    mean_values_feature_df$gene_id=make.unique(get_ID_names(multiassay,
                                                            id=mean_values_feature_df$ensembl,
                                                            assay_name = rna_assay,
                                                            omic = "rna",
                                                            from = "ensembl_gene_id",
                                                            to = "gene_name"))

    processing_outputs[["post_filtering"]]=list(mean_values_feature_df= mean_values_feature_df,
                                                mean_values_sample=  colMeans(counts(dds)),
                                                genes_filtered_out=setdiff(rnas_raw,rnas_filtered),
                                                genes_filtered_out_id= make.unique(get_ID_names(multiassay,
                                                                         id=setdiff(rnas_raw,rnas_filtered),
                                                                         assay_name = rna_assay,
                                                                         omic = "rna",
                                                                         from = "ensembl_gene_id",
                                                                         to = "gene_name")))

    cli::cli_alert_success(paste(keep, "genes kept for analysis"))

    if (transformation == "log2") {
      cli::cli_alert_success("LOG2 TRANSFORMATION")
      suppressMessages({
      matrix <- data.frame(log2(DESeq2::counts(dds, normalized = TRUE) + 1))
      })
    }

    if (transformation == "vst") {
      cli::cli_alert_success("VST TRANSFORMATION")
      suppressMessages({
      vsd <- DESeq2::vst(dds, blind = FALSE)
      matrix <- as.data.frame(SummarizedExperiment::assay(vsd))
      })
    }

    if (transformation == "rlog") {
       cli::cli_alert_success("RLOG TRANSFORMATION")
      suppressMessages({
       rlog <- DESeq2::rlog(dds, blind = FALSE)
       matrix <- as.data.frame(SummarizedExperiment::assay(rlog))
      })
    }
  }

  if (batch_correction == TRUE) {
    cli::cli_alert_success("BATCH CORRECTION")
    cli::cli_alert_success(paste(
      "Using Limma on", batch,
      "to remove technical artefacts, and",
      covariates, "as biological confounders"
    ))
    suppressMessages({
    covariates_data <- MultiAssayExperiment::colData(rna_raw)[, c(covariates)]
    covariates_data <- data.frame(covariates_data)
    covariates_data <- covariates_data %>%
      mutate(across(where(is.character), as.factor))
    covariates_data <- covariates_data %>%
      mutate(across(where(is.factor), as.numeric))
    })

    for (i in colnames(covariates_data)) {
      if (all(!is.na(covariates_data[, i])) == FALSE) {
        stop(cli::cli_alert_danger(
          paste(i, "Contains missing data, please impute or remove this covariate",
            sep = " "
          )
        ))
      }
    }

    if (is.null(batch)) {
      suppressMessages({
      matrix <- limma::removeBatchEffect(
        matrix,
        batch = NULL,
        covariates = covariates_data,
        design = model.matrix(~ colData[[dependent]],
          data = colData
        )
      )
      })
    }
    if (!is.null(batch)) {
      batch_data <- colData[batch]
      batch_data[[batch]] <- as.factor(batch_data[[batch]])

      suppressMessages({
      matrix <- limma::removeBatchEffect(
        matrix,
        batch = batch_data[[batch]],
        covariates = covariates_data,
        design = stats::model.matrix(~ colData[[dependent]],
          data = colData
        )
      )
      })
    }
  }

  # if (remove_feature_outliers == TRUE) {
  #   cli::cli_alert_success(“REMOVING FEATURE OUTLIERS”)
  #   cli::cli_h1(“Remove genes with average gene log2(count)
  #                across samples in bottom and upper 5 percentile”)
  #   dim3 <- dim(matrix)[1]
  #   q <- quantile(matrix, probs = c(0.05), na.rm = TRUE)
  #   q2 <- quantile(matrix, probs = c(0.95), na.rm = TRUE)
  #   idx <- ((rowSums(matrix, 2) / ncol(matrix) > q) &
  #             (rowSums(matrix, 2) / ncol(matrix) < q2))
  #   detected_feature_outliers=names(idx)[idx ==FALSE]
  #   matrix <- matrix[idx, ]
  #   dim4 <- dim(matrix)[1]
  #   cli::cli_alert_success(paste(
  #     dim3 - dim4, “feature outliers out of”,
  #     dim3, “features detected and dropped”
  #   ))
  #   processing_outputs[[“remove_feature_outliers”]]=list(feature_outliers= dim3 - dim4,
  #                                                        percentage_outliers= (dim3 - dim4)/dim3,
  #                                                        detected_feature_outliers= detected_feature_outliers)
  # }
  #


  if (remove_sample_outliers == TRUE) {
    dim2 <- dim(matrix)[2]
    cli::cli_alert_success("SAMPLE OUTLIERS REMOVAL")
    pca <- prcomp(t(matrix), scale. = FALSE, rank. = 1)
    U <- pca$x
    outliers <- rownames(apply(
      U, 2,
      function(x) {
        which(abs(x - mean(x)) >=
          (3 * sd(x)))
      }
    ))
    matrix <- matrix[, colnames(matrix) %!in% outliers]
    cli::cli_alert_success(paste(
      length(outliers), "sample outliers out of",
      dim2, " samples detected and dropped"
    ))

    processing_outputs[["remove_sample_outliers"]]=list(sample_outliers= length(outliers),
                                                         percentage_outliers= length(outliers)/dim2,
                                                         detected_sample_outliers= outliers)
  }
  suppressMessages({
  matrix <- as.data.frame(matrix)
  map <- MultiAssayExperiment::sampleMap(multiassay)
  map_df <- data.frame(map@listData)
  map_df <- map_df[which(map_df$assay == rna_assay), ]
  map_df <- map_df[match(
    colnames(matrix),
    map_df$colname
  ), ][c("primary", "colname")]
  new_name <- gsub("raw","processed",rna_assay)
  map_df$assay <- new_name
  multiassay <- c(multiassay,
    tmp_name_rna = matrix,
    sampleMap = map_df
  )
  names(multiassay)[length(names(multiassay))] <- new_name
  MultiAssayExperiment::metadata(multiassay)$dds <- dds


  if (remove_sample_outliers) {
    MultiAssayExperiment::metadata(multiassay)$OutliersFlags$rna <- outliers
  }

  MultiAssayExperiment::metadata(multiassay)$parameters$processing$rna <- list(
    transformation=transformation,
    min_count = min_count,
    min_sample = min_sample,
    dependent = dependent,
    levels = levels,
    covariates = covariates,
    protein_coding=protein_coding,
    filter = filter,
    batch_correction = batch_correction,
    batch = batch,
    remove_sample_outliers = remove_sample_outliers
  )

  MultiAssayExperiment::metadata(multiassay)$parameters$processing_outputs$rna <- processing_outputs
  })
  cli::cli_alert_success("Transcriptomics data processed!")
  cli::cli_alert_success("Processing parameters saved in metadata")

  return(multiassay)
}
